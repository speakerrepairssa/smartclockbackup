<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Business Dashboard - AiClock</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f7fa;
      color: #333;
    }

    .dashboard-wrapper {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 200px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem 1rem;
      position: fixed;
      height: 100vh;
      overflow-y: auto;
      z-index: 100;
    }

    .sidebar-header {
      font-size: 1.5rem;
      margin-bottom: 2rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sidebar-menu {
      list-style: none;
    }

    .sidebar-menu li {
      margin-bottom: 1rem;
    }

    .sidebar-menu button {
      width: 100%;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      text-align: left;
      transition: all 0.3s ease;
      font-size: 0.95rem;
      font-weight: 500;
    }

    .sidebar-menu button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateX(5px);
    }

    .sidebar-menu button.active {
      background: rgba(255, 255, 255, 0.3);
      border-left: 3px solid white;
    }

    .sidebar-footer {
      position: absolute;
      bottom: 1rem;
      width: 180px;
    }

    .logout-btn {
      width: 100%;
      padding: 0.75rem;
      background: rgba(255, 67, 67, 0.8);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: rgba(255, 67, 67, 1);
    }

    /* Main Content */
    .main-content {
      margin-left: 200px;
      flex: 1;
      padding: 2rem;
    }

    .dashboard-header {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      margin-bottom: 2rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header-title {
      display: flex;
      flex-direction: column;
    }

    .header-title h1 {
      font-size: 1.8rem;
      color: #667eea;
      margin-bottom: 0.25rem;
    }

    .header-title p {
      color: #666;
      font-size: 0.95rem;
    }

    .header-actions {
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 0.95rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: #f0f0f0;
      color: #333;
    }

    .btn-secondary:hover {
      background: #e0e0e0;
    }

    .btn-small {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 1.5rem;
      transition: all 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
    }

    .stat-icon {
      font-size: 2.5rem;
    }

    .stat-label {
      color: #666;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: #667eea;
    }

    .stat-subtext {
      color: #999;
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }

    /* Modules Grid */
    .modules-section {
      margin-top: 2rem;
    }

    .section-title {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #333;
    }

    .section-description {
      color: #666;
      margin-bottom: 1.5rem;
      font-size: 0.95rem;
    }

    .modules-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1.5rem;
    }

    .module-card {
      background: white;
      border-radius: 12px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 2px solid transparent;
    }

    .module-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
      border-color: #667eea;
    }

    .module-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .module-name {
      font-weight: 600;
      color: #333;
      font-size: 0.95rem;
      line-height: 1.4;
    }

    .module-status {
      font-size: 0.8rem;
      color: #999;
      margin-top: 0.5rem;
    }

    /* Views */
    .view-section {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .view-section.active {
      display: block;
    }

    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        height: auto;
        position: relative;
        padding: 1rem;
      }

      .main-content {
        margin-left: 0;
        padding: 1rem;
      }

      .dashboard-header {
        flex-direction: column;
        gap: 1rem;
      }

      .modules-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }

      .stat-card {
        flex-direction: column;
        text-align: center;
      }

      .sidebar-footer {
        position: relative;
        width: 100%;
        margin-top: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="dashboard-wrapper">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-header">üïê AiClock</div>
      <ul class="sidebar-menu">
        <li><button class="menu-btn active" data-module="dashboard" onclick="switchModule('dashboard')">üìä Dashboard</button></li>
        <li><button class="menu-btn" data-module="monitor" onclick="switchModule('monitor')">üî¥ Monitor Mode</button></li>
        <li><button class="menu-btn" data-module="attendance" onclick="switchModule('attendance')">‚úì Attendance</button></li>
        <li><button class="menu-btn" data-module="reports" onclick="switchModule('reports')">üìà Reports</button></li>
        <li><button class="menu-btn" data-module="employees" onclick="switchModule('employees')">üë• Employees</button></li>
        <li><button class="menu-btn" data-module="timecard" onclick="switchModule('timecard')">üïê Timecard</button></li>
        <li><button class="menu-btn" data-module="punches" onclick="switchModule('punches')">üëä Punches</button></li>
        <li><button class="menu-btn" data-module="sync" onclick="switchModule('sync')">üîÑ Device Sync</button></li>
        <li><button class="menu-btn" data-module="sql-integration" onclick="switchModule('sql-integration')">üóÑÔ∏è SQL Integration</button></li>
        <li><button class="menu-btn" data-module="downloads" onclick="switchModule('downloads')">üì• Downloads</button></li>
        <li><a href="whatsapp-settings.html" style="display: block; color: inherit; text-decoration: none;"><button class="menu-btn">üì± WhatsApp</button></a></li>
        <li><button class="menu-btn" data-module="settings" onclick="switchModule('settings')">‚öôÔ∏è Settings</button></li>
      </ul>
      <div class="sidebar-footer">
        <button id="logoutBtn" class="logout-btn">Logout</button>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Header -->
      <div class="dashboard-header">
        <div class="header-title">
          <h1 id="businessName">Business Dashboard</h1>
          <p id="userEmail">Loading...</p>
        </div>
        <div class="header-actions">
          <button class="btn btn-secondary" id="refreshBtn">‚Üª Refresh</button>
        </div>
      </div>

      <!-- Stats Grid -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-icon">üë•</div>
          <div>
            <div class="stat-label">Active Employees</div>
            <div class="stat-value" id="activeEmployees">0</div>
            <div class="stat-subtext" id="slotsText">Out of 0 slots</div>
          </div>
        </div>

        <div class="stat-card">
          <div class="stat-icon">‚úì</div>
          <div>
            <div class="stat-label">Present Today</div>
            <div class="stat-value" id="presentToday">0</div>
            <div class="stat-subtext">Clocked in</div>
          </div>
        </div>

        <div class="stat-card">
          <div class="stat-icon">üïê</div>
          <div>
            <div class="stat-label">Plan Status</div>
            <div class="stat-value" id="planStatus">Basic</div>
            <div class="stat-subtext">Active Plan</div>
          </div>
        </div>

        <div class="stat-card">
          <div class="stat-icon">üéØ</div>
          <div>
            <div class="stat-label">Attendance Rate</div>
            <div class="stat-value" id="attendanceRate">--</div>
            <div class="stat-subtext">This month</div>
          </div>
        </div>
      </div>

      <!-- Dashboard View -->
      <div class="view-section active" id="dashboardView">
        <div class="modules-section">
          <h2 class="section-title">Quick Access Modules</h2>
          <p class="section-description">Click any module to manage your business operations</p>

          <div class="modules-grid">
            <div class="module-card" data-module="monitor">
              <div class="module-icon">üìä</div>
              <div class="module-name">Monitor Mode</div>
              <div class="module-status">Live Status</div>
            </div>

            <div class="module-card" data-module="attendance">
              <div class="module-icon">‚úì</div>
              <div class="module-name">Attendance Tracker</div>
              <div class="module-status">History</div>
            </div>

            <div class="module-card" data-module="timecard">
              <div class="module-icon">üïê</div>
              <div class="module-name">Timecard</div>
              <div class="module-status">Daily Hours</div>
            </div>

            <div class="module-card" data-module="reports">
              <div class="module-icon">üìà</div>
              <div class="module-name">Reports</div>
              <div class="module-status">Analytics</div>
            </div>

            <div class="module-card" data-module="employees">
              <div class="module-icon">üë•</div>
              <div class="module-name">Employees</div>
              <div class="module-status">Manage Staff</div>
            </div>

            <div class="module-card" data-module="downloads">
              <div class="module-icon">üì•</div>
              <div class="module-name">Downloads</div>
              <div class="module-status">Apps & Tools</div>
            </div>

            <div class="module-card" data-module="settings">
              <div class="module-icon">‚öôÔ∏è</div>
              <div class="module-name">Settings</div>
              <div class="module-status">Configuration</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Attendance View -->
      <div class="view-section" id="attendanceView">
        <h2 class="section-title">Attendance History</h2>
        <p class="section-description">View and manage employee attendance records</p>
        
        <div id="attendanceContent" style="padding: 2rem;">
          <div style="text-align: center; color: #999;">
            <p style="font-size: 3rem; margin-bottom: 1rem;">üìã</p>
            <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Attendance Module</p>
            <p>Detailed attendance tracking and history will be available here</p>
            <p style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.7;">Use Timecard for monthly summaries or Monitor for real-time status</p>
          </div>
        </div>
      </div>

      <!-- Monitor View (Real-Time) -->
      <div class="view-section" id="monitorView">
        <style>
          .monitor-header {
            background: #2c3e50;
            color: white;
            padding: 1.5rem;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
          }

          .monitor-title {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 1.5rem;
            font-weight: 700;
          }

          .monitor-actions {
            display: flex;
            gap: 1rem;
          }

          .back-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
          }

          .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
          }

          .monitor-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
          }

          .status-section {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
          }

          .status-header {
            padding: 1rem;
            color: white;
            font-weight: 700;
            font-size: 1.3rem;
            text-align: center;
          }

          .status-header.in {
            background: #4caf50;
          }

          .status-header.out {
            background: #f44336;
          }

          .status-body {
            padding: 1.5rem;
            min-height: 300px;
          }

          .employee-item {
            padding: 1rem;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
          }

          .employee-item:last-child {
            border-bottom: none;
          }

          .employee-name {
            font-weight: 600;
            color: #333;
            font-size: 0.95rem;
          }

          .employee-slot {
            color: #999;
            font-size: 0.85rem;
            margin-top: 0.25rem;
          }

          .employee-time {
            font-size: 1.2rem;
            font-weight: 700;
            color: #f44336;
            text-align: right;
          }

          .no-employees {
            text-align: center;
            color: #999;
            padding: 2rem;
          }

          .monitor-footer {
            background: white;
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            color: #666;
            font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
          }

          .refresh-time {
            color: #667eea;
            font-weight: 600;
          }

          @media (max-width: 768px) {
            .monitor-header {
              flex-direction: column;
              gap: 1rem;
              text-align: center;
            }

            .monitor-content {
              grid-template-columns: 1fr;
            }
          }
        </style>

        <style>
          /* Employee Management Styles */
          .employees-container {
            padding: 1rem;
          }

          .employees-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
          }

          .employee-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            border-left: 4px solid #667eea;
          }

          .employee-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
          }

          .employee-card.inactive {
            border-left-color: #ccc;
            opacity: 0.7;
          }

          .employee-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
          }

          .employee-info h3 {
            margin: 0 0 0.25rem 0;
            color: #2c3e50;
            font-size: 1.1rem;
          }

          .employee-slot-badge {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
          }

          .employee-details {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin: 1rem 0;
          }

          .employee-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.9rem;
          }

          .detail-label {
            color: #666;
            font-weight: 500;
          }

          .detail-value {
            color: #2c3e50;
            font-weight: 600;
          }

          .employee-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
          }

          .employee-status.clocked-in {
            background: #d4edda;
            color: #155724;
          }

          .employee-status.clocked-out {
            background: #f8d7da;
            color: #721c24;
          }

          .employee-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
          }

          .btn-edit {
            flex: 1;
            padding: 0.6rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
          }

          .btn-edit:hover {
            background: #5568d3;
          }

          .btn-view {
            flex: 1;
            padding: 0.6rem;
            background: #48bb78;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
          }

          .btn-view:hover {
            background: #38a169;
          }

          .no-employees {
            text-align: center;
            padding: 3rem;
            color: #999;
            font-size: 1.1rem;
          }

          /* Empty Slot Styles */
          .employee-card.empty-slot {
            background: #f8f9fa;
            border-left-color: #6c757d;
            border-style: dashed;
          }

          .employee-card.empty-slot:hover {
            border-left-color: #28a745;
            background: #f1f8e9;
          }

          .employee-slot-badge.empty {
            background: #6c757d;
          }

          .empty-slot-message {
            text-align: center;
            padding: 1rem 0;
            color: #666;
            font-style: italic;
          }

          .btn-add {
            width: 100%;
            padding: 0.6rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
          }

          .btn-add:hover {
            background: #34ce57;
          }

          /* Settings Styles */
          .settings-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            padding: 2rem;
          }

          .settings-card {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          }

          .settings-card h3 {
            margin-top: 0;
            margin-bottom: 1.5rem;
            color: #2c3e50;
            font-size: 1.2rem;
          }

          .form-group {
            margin-bottom: 1.5rem;
          }

          .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 600;
            font-size: 0.9rem;
          }

          .form-group input,
          .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
            font-family: inherit;
          }

          .form-group small {
            display: block;
            margin-top: 0.25rem;
            color: #6c757d;
            font-size: 0.85rem;
          }

          .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
          }

          .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-weight: 500;
          }

          .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
          }

          .day-settings {
            display: flex;
            flex-direction: column;
            gap: 1rem;
          }

          .day-config {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1rem;
            background: #f8f9fa;
          }

          .day-header {
            margin-bottom: 0.75rem;
          }

          .day-header label {
            font-size: 1rem;
            cursor: pointer;
          }

          .day-checkbox {
            width: auto !important;
            margin-right: 0.5rem;
          }

          .day-details {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
          }

          .day-details input {
            padding: 0.5rem;
            font-size: 0.9rem;
          }

          /* Employee Edit Modal */
          .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 1rem;
          }

          .modal-employee {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
          }

          .modal-employee h2 {
            margin: 0 0 1.5rem 0;
            color: #2c3e50;
          }

          .form-group {
            margin-bottom: 1.25rem;
          }

          .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 600;
            font-size: 0.9rem;
          }

          .form-group input,
          .form-group select,
          .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
            font-family: inherit;
          }

          .form-group input:focus,
          .form-group select:focus,
          .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
          }

          .form-group textarea {
            resize: vertical;
            min-height: 80px;
          }

          .form-group input[readonly] {
            background: #f5f5f5;
            color: #666;
          }

          .modal-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
          }

          .btn-save {
            flex: 1;
            padding: 0.75rem;
            background: #48bb78;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: background 0.2s;
          }

          .btn-save:hover {
            background: #38a169;
          }

          .btn-cancel {
            flex: 1;
            padding: 0.75rem;
            background: #e2e8f0;
            color: #2c3e50;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: background 0.2s;
          }

          .btn-cancel:hover {
            background: #cbd5e0;
          }

          @media (max-width: 768px) {
            .employees-grid {
              grid-template-columns: 1fr;
            }
          }
        </style>

        <style>
          /* Timecard Module Styles */
          .timecard-container {
            padding: 1rem;
          }

          .timecard-controls,
          .report-controls {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 1rem;
            align-items: end;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
          }

          .control-group {
            flex: 1;
            min-width: 200px;
          }

          .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-weight: 600;
            font-size: 0.9rem;
          }

          .control-group select,
          .control-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
            font-family: inherit;
          }

          .btn-refresh-timecard,
          .btn-print-timecard,
          .btn-refresh-reports,
          .btn-print-reports {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.2s;
          }

          .btn-refresh-timecard,
          .btn-refresh-reports {
            background: #667eea;
            color: white;
          }

          .btn-refresh-timecard:hover,
          .btn-refresh-reports:hover {
            background: #5568d3;
          }

          .btn-print-timecard,
          .btn-print-reports {
            background: #48bb78;
            color: white;
          }

          .btn-print-timecard:hover,
          .btn-print-reports:hover {
            background: #38a169;
          }

          .timecard-display {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
          }

          .timecard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
          }

          .timecard-header h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.5rem;
          }

          .timecard-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.95rem;
          }

          .timecard-table-wrapper {
            overflow-x: auto;
            padding: 1rem;
          }

          .timecard-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
          }

          .timecard-table th {
            background: #f8f9fa;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #dee2e6;
          }

          .timecard-table th:last-child,
          .timecard-table td:last-child {
            text-align: right;
          }

          .timecard-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #e9ecef;
            color: #495057;
          }

          .timecard-table tr:hover {
            background: #f8f9fa;
          }

          .day-date {
            font-weight: 600;
            color: #2c3e50;
          }

          .day-name {
            color: #6c757d;
            font-size: 0.85rem;
          }

          .weekend {
            background: #fff3cd !important;
          }

          .no-data {
            color: #999;
            font-style: italic;
          }

          .time-in, .time-out {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
          }

          .hours-worked {
            font-weight: 600;
            color: #48bb78;
          }

          .overtime {
            color: #f6ad55;
            font-weight: 600;
          }

          /* Status styling for punch records */
          .clocked-in {
            color: #48bb78;
            font-weight: 600;
          }

          .clocked-out {
            color: #4299e1;
            font-weight: 600;
          }

          .pending {
            color: #f6ad55;
            font-weight: 600;
            background: #fffbeb;
            padding: 2px 6px;
            border-radius: 4px;
          }

          .unmatched {
            color: #e53e3e;
            font-weight: 600;
          }

          .no-data {
            color: #999;
            font-style: italic;
          }

          /* Enhanced time display */
          .time-in {
            color: #48bb78;
            font-weight: 600;
          }

          .time-out {
            color: #4299e1;
            font-weight: 600;
          }

          /* Sync Module Styles */
          .sync-container {
            padding: 1rem;
          }

          .sync-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
          }

          .sync-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          }

          .sync-card h3 {
            margin: 0 0 1rem 0;
            color: #374151;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
          }

          .sync-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
          }

          .status-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f3f4f6;
          }

          .status-label {
            color: #6b7280;
            font-weight: 500;
          }

          .events-comparison {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          }

          .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
          }

          .comparison-table th,
          .comparison-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
          }

          .comparison-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
          }

          .event-matched {
            background: #f0fff4;
            color: #22c55e;
          }

          .event-missing {
            background: #fef2f2;
            color: #ef4444;
          }

          .event-extra {
            background: #fff7ed;
            color: #f59e0b;
          }

          .device-collections {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
          }

          .device-collection-item {
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
          }

          .device-info {
            font-weight: 600;
            margin-bottom: 0.25rem;
          }

          .device-id {
            color: #6b7280;
            font-weight: normal;
            font-size: 0.9rem;
          }

          .collection-status {
            font-size: 0.85rem;
            font-family: 'Courier New', monospace;
          }

          .comparison-summary {
            background: #f3f4f6;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
          }

          .comparison-summary h4 {
            margin: 0 0 0.5rem 0;
          }

          .comparison-summary p {
            margin: 0.25rem 0;
          }

          .collection-status.error {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #dc2626;
          }

          .collection-status.success {
            background: #d1fae5;
            border-color: #86efac;
            color: #059669;
          }

          .comparison-table tr.event-matched {
            background: #f0f9ff;
          }

          .comparison-table tr.event-missing {
            background: #fef3c7;
          }

          .error {
            color: #dc2626;
            background: #fee2e2;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #fca5a5;
          }

          .timecard-summary {
            background: #f8f9fa;
            padding: 1.5rem;
            border-top: 3px solid #667eea;
          }

          .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
          }

          .summary-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
          }

          .summary-item.overtime-item {
            border-left-color: #f6ad55;
          }

          .summary-item.total-item {
            border-left-color: #48bb78;
          }

          .summary-label {
            color: #6c757d;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
          }

          .summary-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2c3e50;
          }

          /* ============================================
             REPORTS MODULE STYLES
             ============================================ */

          .reports-container {
            padding: 1rem;
          }

          .report-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
          }

          .report-header h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.8rem;
          }

          .report-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.95rem;
          }

          .report-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
          }

          .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            border-left: 4px solid #667eea;
            transition: transform 0.2s, box-shadow 0.2s;
          }

          .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
          }

          .stat-card.highlight {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border-left: 4px solid #2f855a;
          }

          .stat-label {
            font-size: 0.85rem;
            color: #6c757d;
            margin-bottom: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
          }

          .stat-card.highlight .stat-label {
            color: rgba(255, 255, 255, 0.9);
          }

          .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
          }

          .stat-card.highlight .stat-value {
            color: white;
          }

          .report-section {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
          }

          .report-section h4 {
            margin: 0 0 1.5rem 0;
            color: #2c3e50;
            font-size: 1.3rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #667eea;
          }

          .report-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
          }

          .report-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
          }

          .report-table th {
            padding: 1rem 0.75rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
          }

          .report-table td {
            padding: 0.9rem 0.75rem;
            border-bottom: 1px solid #e2e8f0;
          }

          .report-table tbody tr:hover {
            background: #f7fafc;
          }

          .report-table tbody tr:last-child td {
            border-bottom: none;
          }

          .report-table .total-row {
            background: #f8f9fa !important;
            font-weight: 700;
            border-top: 2px solid #667eea;
          }

          .report-table .total-row td {
            padding: 1.2rem 0.75rem;
            color: #2c3e50;
          }

          @media print {
            /* Hide everything first */
            * {
              visibility: hidden;
            }

            /* Show timecard or reports elements */
            #timecardView,
            #timecardView *,
            #reportsView,
            #reportsView *,
            .print-company-info,
            .print-company-info *,
            .timecard-display,
            .timecard-display *,
            .reports-container,
            .reports-container *,
            .print-footer,
            .print-footer * {
              visibility: visible;
            }

            /* Completely hide dashboard and other sections */
            .sidebar,
            .header,
            .menu-sidebar,
            .btn-refresh-timecard,
            .btn-print-timecard,
            .btn-refresh-reports,
            .btn-print-reports,
            .timecard-controls,
            .report-controls,
            .section-title,
            .section-description,
            #dashboardView,
            #monitorView,
            #employeesView,
            #attendanceView,
            #settingsView {
              display: none !important;
              visibility: hidden !important;
            }

            /* Reset page styling */
            body {
              background: white !important;
              margin: 0 !important;
              padding: 0 !important;
              font-family: Arial, sans-serif !important;
            }

            /* Position timecard at top */
            #timecardView {
              position: absolute !important;
              top: 0 !important;
              left: 0 !important;
              width: 100% !important;
              padding: 0 !important;
              margin: 0 !important;
            }

            .timecard-container {
              padding: 0 !important;
              margin: 0 !important;
            }

            /* Company header styling - compact */
            .print-company-info {
              display: block !important;
              padding: 0.8rem !important;
              background: #f8f9fa !important;
              border-bottom: 2px solid #667eea !important;
              text-align: center !important;
              margin: 0 !important;
              -webkit-print-color-adjust: exact !important;
              color-adjust: exact !important;
            }

            .print-company-info h2 {
              margin: 0 0 0.3rem 0 !important;
              color: #2c3e50 !important;
              font-size: 1.2rem !important;
            }

            .print-company-info p {
              margin: 0 !important;
              color: #6c757d !important;
              font-size: 0.9rem !important;
            }

            /* Timecard display styling */
            .timecard-display {
              box-shadow: none !important;
              border-radius: 0 !important;
              margin: 0 !important;
              padding: 0 !important;
              background: white !important;
            }

            /* Timecard header - compact */
            .timecard-header {
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
              color: white !important;
              padding: 1rem !important;
              text-align: center !important;
              margin: 0 !important;
              -webkit-print-color-adjust: exact !important;
              color-adjust: exact !important;
            }

            .timecard-header h3 {
              font-size: 1.3rem !important;
              margin: 0 0 0.3rem 0 !important;
              color: white !important;
            }

            .timecard-header p {
              font-size: 0.9rem !important;
              margin: 0 !important;
              color: white !important;
              opacity: 0.95 !important;
            }

            /* Business timecard table styling */
            .timecard-table-wrapper {
              padding: 10px 20px !important;
            }

            .timecard-table {
              width: 100% !important;
              border-collapse: collapse !important;
              font-size: 9pt !important;
              margin: 0 !important;
              border: 1px solid black !important;
            }

            .timecard-table th {
              background: white !important;
              color: black !important;
              padding: 8px 4px !important;
              text-align: center !important;
              font-weight: bold !important;
              border: 1px solid black !important;
              font-size: 8pt !important;
            }

            .timecard-table td {
              padding: 6px 4px !important;
              border: 1px solid black !important;
              color: black !important;
              font-size: 8pt !important;
              text-align: center !important;
            }

            .timecard-table tr:nth-child(even) {
              background: white !important;
            }

            .weekend {
              background: #f5f5f5 !important;
            }

            /* Business timecard summary section */
            .timecard-summary {
              background: white !important;
              padding: 15px 20px !important;
              border-top: 2px solid black !important;
              display: flex !important;
              justify-content: space-between !important;
            }

            .summary-grid {
              display: flex !important;
              justify-content: space-between !important;
              width: 100% !important;
              gap: 40px !important;
            }

            .summary-section {
              display: flex !important;
              flex-direction: column !important;
              align-items: flex-start !important;
            }

            .summary-item {
              background: white !important;
              padding: 0 !important;
              border: none !important;
              text-align: left !important;
              margin-bottom: 5px !important;
              display: flex !important;
              align-items: center !important;
            }

            .summary-label {
              color: black !important;
              font-size: 10pt !important;
              font-weight: bold !important;
              margin-right: 15px !important;
              min-width: 80px !important;
            }

            .summary-value {
              font-size: 12pt !important;
              font-weight: bold !important;
              color: black !important;
            }

            /* Hide print footer for business format */
            .print-footer {
              display: none !important;
            }

            /* Page setup - single page */
            @page {
              margin: 0.4in;
              size: letter;
            }

            /* Page break controls */
            .timecard-table {
              page-break-inside: auto !important;
            }

            .timecard-table tr {
              page-break-inside: avoid !important;
            }

            .timecard-table thead {
              display: table-header-group !important;
            }
          }

          @media (max-width: 768px) {
            .timecard-controls {
              flex-direction: column;
              align-items: stretch;
            }

            .control-group {
              min-width: 100%;
            }

            .timecard-table {
              font-size: 0.8rem;
            }

            .timecard-table th,
            .timecard-table td {
              padding: 0.5rem;
            }
          }

          /* PUNCHES STYLES */
          .punches-controls {
            display: flex;
            gap: 1rem;
            align-items: end;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          }

          .punches-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
          }

          .punch-stat-card {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #007cba;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          }

          .punch-stat-card h4 {
            margin: 0;
            color: #333;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
          }

          .punch-stat-card p {
            margin: 0.5rem 0 0 0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #007cba;
          }

          .punches-table-container {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          }

          .punches-table {
            width: 100%;
            border-collapse: collapse;
          }

          .punches-table th,
          .punches-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
          }

          .punches-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #374151;
          }

          .punches-table tbody tr:hover {
            background: #f9fafb;
          }

          .punch-status {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
          }

          .punch-status.matched {
            background: #d1fae5;
            color: #059669;
          }

          .punch-status.pending {
            background: #fef3c7;
            color: #d97706;
          }

          .punch-status.unmatched {
            background: #fee2e2;
            color: #dc2626;
          }

          .punch-status.mispunch {
            background: #fef3c7;
            color: #d97706;
            position: relative;
          }

          .mispunch-actions {
            margin-left: 0.5rem;
          }

          .btn-mispunch {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
            margin-left: 0.25rem;
          }

          .btn-mispunch:hover {
            background: #d97706;
          }

          .punch-actions {
            display: flex;
            gap: 0.5rem;
          }

          .punch-action-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            font-weight: 500;
          }

          .punch-action-btn.resolve {
            background: #3b82f6;
            color: white;
          }

          .punch-action-btn.delete {
            background: #ef4444;
            color: white;
          }

          /* Modal Styles */
          .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
          }

          .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
          }

          .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
          }

          .modal-header h3 {
            margin: 0;
            color: #374151;
          }

          .close {
            color: #6b7280;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0.25rem;
          }

          .close:hover {
            color: #374151;
          }

          .modal-body {
            padding: 1.5rem;
          }

          .resolution-options {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
          }

          .resolution-options h4 {
            margin-bottom: 1rem;
            color: #374151;
          }

          .resolution-options button {
            margin: 0.25rem 0.5rem 0.25rem 0;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
          }

          @media (max-width: 768px) {
            .punches-controls {
              flex-direction: column;
              align-items: stretch;
            }

            .punches-table {
              font-size: 0.8rem;
            }

            .punches-table th,
            .punches-table td {
              padding: 0.5rem 0.25rem;
            }

            .punch-actions {
              flex-direction: column;
            }
          }
        </style>

        <!-- Monitor Header -->
        <div class="monitor-header">
          <div class="monitor-title">
            <button class="back-btn" onclick="switchModule('dashboard')">‚Üê Back</button>
            <span>üïê LIVE ATTENDANCE MONITOR</span>
          </div>
          <button class="btn btn-primary" onclick="loadMonitorData()">‚Üª Refresh</button>
        </div>

        <!-- Debug Section -->
        <div style="background: #fff3cd; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border: 1px solid #ffc107;">
          <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <button class="btn btn-small" onclick="addTestEmployee()" style="background: #28a745; color: white;">+ Add Test Employee (IN)</button>
            <button class="btn btn-small" onclick="addTestEmployeeOut()" style="background: #dc3545; color: white;">+ Add Test Employee (OUT)</button>
            <button class="btn btn-small" onclick="clearAllStaff()" style="background: #6c757d; color: white;">Clear All Staff</button>
          </div>
        </div>

        <!-- Monitor Content -->
        <div class="monitor-content" id="monitorContent">
          <!-- IN Section -->
          <div class="status-section">
            <div class="status-header in">IN</div>
            <div class="status-body" id="inEmployees">
              <div class="no-employees">Loading...</div>
            </div>
          </div>

          <!-- OUT Section -->
          <div class="status-section">
            <div class="status-header out">OUT</div>
            <div class="status-body" id="outEmployees">
              <div class="no-employees">Loading...</div>
            </div>
          </div>
        </div>

        <!-- Monitor Footer -->
        <div class="monitor-footer">
          ‚è± Auto-refreshes every 30 seconds ‚Ä¢ Last updated: <span class="refresh-time" id="lastUpdateTime">Just now</span>
        </div>
      </div>

      <!-- Reports View -->
      <div class="view-section" id="reportsView">
        <h2 class="section-title">Reports</h2>
        <p class="section-description">View detailed attendance and performance reports</p>
        
        <div class="reports-container">
          <!-- Report Selection Controls -->
          <div class="report-controls">
            <div class="control-group">
              <label for="reportMonth">Select Month:</label>
              <input type="month" id="reportMonth" onchange="loadReports()">
            </div>
            <button class="btn-refresh-reports" onclick="loadReports()">üîÑ Refresh Reports</button>
            <button class="btn-print-reports" onclick="printReports()">üñ®Ô∏è Print</button>
          </div>

          <!-- Reports Content -->
          <div id="reportsContent" style="padding: 2rem;">
            <div style="text-align: center; color: #999;">Select a month to generate reports</div>
          </div>
        </div>
      </div>

      <!-- Employees View -->
      <div class="view-section" id="employeesView">
        <h2 class="section-title">Employee Management</h2>
        <p class="section-description">Manage employee details and HR information</p>
        
        <div class="employee-management-header" style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
          <div class="employee-stats">
            <span id="employeeCount" style="color: #666; font-size: 0.9rem;">Loading employees...</span>
          </div>
          <button class="btn btn-primary" onclick="addNewEmployee()" style="background: #28a745;">
            <span style="margin-right: 0.5rem;">üë§</span>Add New Employee
          </button>
        </div>
        
        <div class="employees-container">
          <div id="employeesGrid" class="employees-grid">
            <!-- Employee cards will be loaded here -->
          </div>
        </div>
      </div>

      <!-- Timecard View -->
      <div class="view-section" id="timecardView">
        <h2 class="section-title">Employee Timecard</h2>
        <p class="section-description">View monthly attendance and calculate working hours</p>
        
        <div class="timecard-container">
          <!-- Print-Only Company Header (Hidden on Screen) -->
          <div class="print-company-info" style="display: none;">
            <h1>TIME CARD REPORT</h1>
            <div class="timecard-details">
              <div class="detail-row">
                <div class="detail-item">
                  <label>PayPeriod:</label>
                  <span>Monthly</span>
                </div>
                <div class="detail-item">
                  <label>Roster:</label>
                  <span>General</span>
                </div>
              </div>
              <div class="detail-row">
                <div class="detail-item">
                  <label>Division:</label>
                  <span>Admin</span>
                </div>
                <div class="detail-item">
                  <label>Group:</label>
                  <span>All</span>
                </div>
              </div>
              <div class="detail-row">
                <div class="detail-item">
                  <label>Department:</label>
                  <span>All</span>
                </div>
                <div class="detail-item">
                  <label>Cost Centre:</label>
                  <span>All</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Selection Controls -->
          <div class="timecard-controls">
            <div class="control-group">
              <label for="employeeSelect">Select Employee:</label>
              <select id="employeeSelect" onchange="loadTimecard()">
                <option value="">-- Select Employee --</option>
              </select>
            </div>
            
            <div class="control-group">
              <label for="monthSelect">Select Month:</label>
              <input type="month" id="monthSelect" onchange="loadTimecard()">
            </div>
            
            <button class="btn-refresh-timecard" onclick="loadTimecard()">üîÑ Refresh</button>
            <button class="btn-print-timecard" onclick="printTimecard()">üñ®Ô∏è Print</button>
            <button class="btn-refresh-timecard" onclick="cleanupAttendanceEvents()" style="background: #dc3545;">üßπ Clean Data</button>
            <button class="btn-refresh-timecard" onclick="checkForDuplicates()" style="background: #28a745;">üîç Check Issues</button>
          </div>
          
          <!-- Timecard Display -->
          <div id="timecardDisplay" class="timecard-display">
            <div style="text-align: center; padding: 3rem; color: #999;">
              Select an employee and month to view timecard
            </div>
          </div>

          <!-- Print-Only Footer (Hidden on Screen) -->
          <div class="print-footer" style="display: none;">
            <p>Generated on <span id="printDate"></span> | AI Clock Attendance System</p>
            <p>This is an official timecard record. For questions, contact your supervisor.</p>
          </div>
        </div>
      </div>

      <!-- Punches View -->
      <div class="view-section" id="punchesView">
        <h2 class="section-title">Punch Management</h2>
        
        <div class="punches-controls">
          <div class="control-group">
            <label for="punchDateFilter">Filter by Date:</label>
            <input type="date" id="punchDateFilter" onchange="loadPunches()">
          </div>
          <div class="control-group">
            <label for="punchEmployeeFilter">Filter by Employee:</label>
            <select id="punchEmployeeFilter" onchange="loadPunches()">
              <option value="">All Employees</option>
            </select>
          </div>
          <div class="control-group">
            <label for="punchStatusFilter">Filter by Status:</label>
            <select id="punchStatusFilter" onchange="loadPunches()">
              <option value="">All Status</option>
              <option value="matched">Matched</option>
              <option value="pending">Misspunches (Pending)</option>
              <option value="unmatched">Unmatched</option>
            </select>
          </div>
          <button onclick="loadPunches()" class="btn-primary">üîÑ Refresh</button>
          <button onclick="openManualPunchModal()" class="btn-success" style="background: #28a745; margin-left: 10px;">‚ûï Add Manual Punch</button>
        </div>

        <div class="punches-summary" id="punchesSummary">
          <!-- Summary will be populated here -->
        </div>

        <div class="punches-table-container">
          <table class="punches-table" id="punchesTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Employee</th>
                <th>Time</th>
                <th>Action</th>
                <th>Device</th>
                <th>Status</th>
                <th>Issue</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="punchesTableBody">
              <!-- Punches will be populated here -->
            </tbody>
          </table>
        </div>

        <!-- Punch Resolution Modal -->
        <div id="punchModal" class="modal">
          <div class="modal-content">
            <div class="modal-header">
              <h3>Resolve Punch Issue</h3>
              <span class="close" onclick="closePunchModal()">&times;</span>
            </div>
            <div class="modal-body">
              <div id="punchDetails">
                <!-- Punch details will be populated here -->
              </div>
              <div class="resolution-options">
                <h4>Resolution Options:</h4>
                <button onclick="markPunchValid()" class="btn-success">‚úÖ Mark as Valid Punch</button>
                <button onclick="deletePunch()" class="btn-danger">üóëÔ∏è Delete Misspunch</button>
                <button onclick="adjustPunchTime()" class="btn-warning">‚è∞ Adjust Time</button>
                <button onclick="convertToBreak()" class="btn-info">‚òï Convert to Break</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Manual Punch Modal -->
        <div id="manualPunchModal" class="modal">
          <div class="modal-content">
            <div class="modal-header">
              <h3>Add Manual Punch</h3>
              <span class="close" onclick="closeManualPunchModal()">&times;</span>
            </div>
            <div class="modal-body">
              <form id="manualPunchForm">
                <div class="form-group">
                  <label for="manualEmployeeSelect">Employee:</label>
                  <select id="manualEmployeeSelect" required onchange="updateManualPunchEmployee()">
                    <option value="">-- Select Employee --</option>
                  </select>
                </div>
                
                <div class="form-group">
                  <label for="manualPunchDate">Date:</label>
                  <input type="date" id="manualPunchDate" required>
                </div>
                
                <div class="form-group">
                  <label for="manualPunchTime">Time:</label>
                  <input type="time" id="manualPunchTime" required>
                </div>
                
                <div class="form-group">
                  <label for="manualPunchType">Punch Type:</label>
                  <select id="manualPunchType" required>
                    <option value="">Select punch type</option>
                    <option value="clock_in">Clock In</option>
                    <option value="clock_out">Clock Out</option>
                    <option value="break_start">Break Start</option>
                    <option value="break_end">Break End</option>
                  </select>
                </div>
                
                <div class="form-group">
                  <label for="manualDeviceId">Device ID (optional):</label>
                  <input type="text" id="manualDeviceId" placeholder="Enter device ID or leave empty">
                </div>
                
                <div class="form-group">
                  <label for="manualNotes">Notes (optional):</label>
                  <textarea id="manualNotes" placeholder="Add any notes about this manual punch" rows="3"></textarea>
                </div>
                
                <div class="form-actions">
                  <button type="button" onclick="submitManualPunch()" class="btn-primary">üíæ Add Punch</button>
                  <button type="button" onclick="closeManualPunchModal()" class="btn-secondary">‚ùå Cancel</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>

      <!-- Device Sync View -->
      <div class="view-section" id="syncView">
        <h2 class="section-title">Device Event Sync</h2>
        <p class="section-description">Monitor device event mirroring and automatic synchronization</p>
        
        <div class="sync-container">
          <!-- Sync Status Cards -->
          <div class="sync-status-grid">
            <div class="sync-card">
              <h3>üì± Device Collections</h3>
              <div id="deviceCollectionsList">
                <p>Loading device collections...</p>
              </div>
              <button class="btn-primary" onclick="loadDeviceCollections()">üîÑ Refresh</button>
            </div>
            
            <div class="sync-card">
              <h3>üîç Sync Status</h3>
              <div id="syncStatusInfo">
                <div class="status-item">
                  <span class="status-label">Last Auto-Sync:</span>
                  <span id="lastSyncTime">Never</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Events Mirrored Today:</span>
                  <span id="eventsMirrored">0</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Missing Events Found:</span>
                  <span id="missingEvents">0</span>
                </div>
              </div>
              <button class="btn-primary" onclick="triggerManualSync()">üîß Manual Sync</button>
            </div>
            
            <div class="sync-card">
              <h3>‚öôÔ∏è Sync Controls</h3>
              <div class="sync-controls">
                <div class="form-group">
                  <label>Device to Sync:</label>
                  <select id="syncDeviceSelect">
                    <option value="">All Devices</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>Date to Sync:</label>
                  <input type="date" id="syncDateSelect">
                </div>
                <div class="sync-actions" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                  <button class="btn-primary" onclick="triggerManualSync()">üîÑ Manual Sync</button>
                  <button class="btn-secondary" onclick="viewDeviceEvents()">üëÅÔ∏è View Events</button>
                  <button class="btn-warning" onclick="compareEvents()">üîç Compare Data</button>
                  <button class="btn-success" onclick="importTestEvents()" style="background: #28a745; color: white;">üß™ Import Test Events</button>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Event Comparison Table -->
          <div class="events-comparison">
            <h3>üìä Event Comparison</h3>
            <div id="eventsComparisonTable">
              <p>Select a device and date to compare raw device events vs processed events</p>
            </div>
          </div>
        </div>
      </div>

      <!-- SQL Integration View -->
      <div class="view-section" id="sqlIntegrationView">
        <h2 class="section-title">üóÑÔ∏è SQL Database Integration</h2>
        <p class="section-description">Manage optional SQL database integration for enhanced device sync</p>
        
        <div class="sql-integration-container">
          <!-- SQL Status Card -->
          <div class="sql-status-card" style="background: white; border-radius: 12px; padding: 2rem; margin-bottom: 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem;">
              <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem;">üóÑÔ∏è</div>
              <div>
                <h3 style="margin: 0; color: #333;">SQL Service Status</h3>
                <p id="sqlStatusText" style="margin: 5px 0 0 0; color: #666;">Checking connection...</p>
              </div>
            </div>
            
            <div id="sqlStatusDetails" style="background: #f8f9fa; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                <div>
                  <strong>Service Endpoint:</strong><br>
                  <span id="sqlEndpoint">http://localhost:3001</span>
                </div>
                <div>
                  <strong>Connection Status:</strong><br>
                  <span id="sqlConnectionStatus">Disconnected</span>
                </div>
                <div>
                  <strong>Database:</strong><br>
                  <span id="sqlDatabaseStatus">Not connected</span>
                </div>
                <div>
                  <strong>Device Count:</strong><br>
                  <span id="sqlDeviceCount">0</span>
                </div>
              </div>
            </div>

            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
              <button id="sqlTestConnectionBtn" class="btn btn-secondary">üîç Test Connection</button>
              <button id="sqlInitializeBtn" class="btn btn-primary" style="display: none;">üöÄ Initialize SQL</button>
              <button id="sqlStartServiceBtn" class="btn btn-success">üîß Start SQL Service</button>
            </div>
          </div>

          <!-- Firebase Data Connect Section -->
          <div class="dataconnect-card" style="background: white; border-radius: 12px; padding: 2rem; margin-bottom: 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem;">
              <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #4285f4, #34a853); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem;">üî•</div>
              <div>
                <h3 style="margin: 0; color: #333;">Firebase Data Connect</h3>
                <p id="dataConnectStatusText" style="margin: 5px 0 0 0; color: #666;">Google's managed PostgreSQL</p>
              </div>
            </div>
            
            <div id="dataConnectStatusDetails" style="background: #f8f9fa; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                <div>
                  <strong>Service:</strong><br>
                  <span id="dataConnectService">device-events (us-central1)</span>
                </div>
                <div>
                  <strong>Status:</strong><br>
                  <span id="dataConnectConnectionStatus">Ready to connect</span>
                </div>
                <div>
                  <strong>Database:</strong><br>
                  <span id="dataConnectDatabaseStatus">Cloud SQL PostgreSQL</span>
                </div>
                <div>
                  <strong>Events Stored:</strong><br>
                  <span id="dataConnectEventCount">0</span>
                </div>
              </div>
            </div>

            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
              <button id="dataConnectInitBtn" class="btn btn-primary">üöÄ Initialize Data Connect</button>
              <button id="dataConnectTestBtn" class="btn btn-secondary" style="display: none;">üìä Test Query</button>
              <button id="addHikvisionDeviceBtn" class="btn btn-success" style="display: none;">üì± Add Hikvision Device</button>
            </div>
          </div>

          <!-- SQL Service Setup -->
          <div class="sql-setup-card" style="background: white; border-radius: 12px; padding: 2rem; margin-bottom: 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; color: #333;">üìã Setup Instructions</h3>
            
            <div class="setup-steps" style="display: grid; gap: 1rem;">
              <div class="setup-step" style="display: flex; align-items: flex-start; gap: 1rem;">
                <div style="width: 30px; height: 30px; background: #667eea; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px;">1</div>
                <div>
                  <strong>Start SQL Service</strong>
                  <p style="margin: 5px 0; color: #666;">Open terminal and run: <code>cd sql-service && npm start</code></p>
                </div>
              </div>
              
              <div class="setup-step" style="display: flex; align-items: flex-start; gap: 1rem;">
                <div style="width: 30px; height: 30px; background: #667eea; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px;">2</div>
                <div>
                  <strong>Setup PostgreSQL Database</strong>
                  <p style="margin: 5px 0; color: #666;">Configure your PostgreSQL connection string</p>
                </div>
              </div>
              
              <div class="setup-step" style="display: flex; align-items: flex-start; gap: 1rem;">
                <div style="width: 30px; height: 30px; background: #667eea; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px;">3</div>
                <div>
                  <strong>Test Connection</strong>
                  <p style="margin: 5px 0; color: #666;">Click "Test Connection" to verify the service is running</p>
                </div>
              </div>
            </div>

            <div style="background: #e3f2fd; border-radius: 8px; padding: 1rem; margin-top: 1rem; border-left: 4px solid #2196f3;">
              <strong>üí° Pro Tip:</strong> SQL integration is completely optional. Your system works perfectly with Firestore only.
            </div>
          </div>

          <!-- Device Integration Controls -->
          <div class="sql-devices-card" style="background: white; border-radius: 12px; padding: 2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; color: #333;">üì± Real Device Sync</h3>
            
            <div id="hikvisionDeviceSection" style="margin-top: 1rem;">
              <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #28a745, #20c997); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;">üìπ</div>
                <div>
                  <h4 style="margin: 0; color: #333;">Hikvision Camera Sync</h4>
                  <p style="margin: 5px 0 0 0; color: #666;">Connect to your Hikvision camera at 192.168.0.114</p>
                </div>
                <div id="deviceStatus" style="margin-left: auto; padding: 0.5rem 1rem; border-radius: 20px; background: #dc3545; color: white; font-weight: 500; font-size: 14px;">
                  Device Offline
                </div>
              </div>
              
              <form id="deviceConnectForm" style="margin-bottom: 1rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div class="form-group">
                    <label for="deviceIp" style="font-weight: 600;">Device IP:</label>
                    <input type="text" id="deviceIp" value="192.168.0.114" required style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                  </div>
                  <div class="form-group">
                    <label for="deviceUsername" style="font-weight: 600;">Username:</label>
                    <input type="text" id="deviceUsername" value="admin" required style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                  </div>
                  <div class="form-group">
                    <label for="devicePassword" style="font-weight: 600;">Password:</label>
                    <input type="password" id="devicePassword" value="Azam198419880001" required style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                  </div>
                </div>
                
                <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                  <button type="submit" class="btn" style="background: #007bff; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: 500;">üîó Connect Device</button>
                  <button type="button" id="startSyncBtn" class="btn" disabled style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: 500; opacity: 0.5;">‚ñ∂Ô∏è Start Live Sync</button>
                  <button type="button" id="stopSyncBtn" class="btn" disabled style="background: #dc3545; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: 500; opacity: 0.5;">‚è∏Ô∏è Stop Sync</button>
                  <button type="button" id="credentialHelperBtn" class="btn" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: 500;">üîë Credential Helper</button>
                </div>
              </form>
              
              <div id="credentialHelper" style="display: none; margin: 1rem 0; padding: 1rem; background: #e9ecef; border-radius: 8px;">
                <h5 style="margin: 0 0 1rem 0; color: #333;">üîë Common Hikvision Default Credentials</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                  <button type="button" class="credential-btn" onclick="useCredentials('admin', 'password')" style="padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; text-align: left;">
                    <strong>admin</strong> / password
                  </button>
                  <button type="button" class="credential-btn" onclick="useCredentials('admin', '12345')" style="padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; text-align: left;">
                    <strong>admin</strong> / 12345
                  </button>
                  <button type="button" class="credential-btn" onclick="useCredentials('admin', 'admin')" style="padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; text-align: left;">
                    <strong>admin</strong> / admin
                  </button>
                  <button type="button" class="credential-btn" onclick="useCredentials('admin', '123456')" style="padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; text-align: left;">
                    <strong>admin</strong> / 123456
                  </button>
                  <button type="button" class="credential-btn" onclick="useCredentials('admin', '')" style="padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; text-align: left;">
                    <strong>admin</strong> / [blank]
                  </button>
                  <button type="button" class="credential-btn" onclick="useCredentials('root', 'password')" style="padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; text-align: left;">
                    <strong>root</strong> / password
                  </button>
                </div>
                <p style="margin: 1rem 0 0 0; font-size: 14px; color: #666;">
                  <strong>üí° Tip:</strong> Many cameras require setting a password on first setup. Check your camera's label or manual for defaults.
                </p>
              </div>
              
              <div id="deviceResults" style="margin-bottom: 1rem;"></div>
              
              <div id="liveEvents" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa;">
                <div style="padding: 1rem; border-bottom: 1px solid #ddd; background: white; border-radius: 8px 8px 0 0;">
                  <h4 style="margin: 0; color: #333;">üì° Live Events Stream</h4>
                  <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">Real-time events from your Hikvision camera</p>
                </div>
                <div id="eventsList" style="padding: 1rem;">
                  <div style="text-align: center; color: #888; padding: 2rem;">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚è≥</div>
                    Connect to device to see live events
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Settings View -->
      <div class="view-section" id="settingsView">
        <h2 class="section-title">Business Settings</h2>
        <p class="section-description">Configure your business preferences and working hours</p>
        
        <div class="settings-container">
          <div class="settings-card">
            <h3>üìã Business Information</h3>
            <form id="businessInfoForm">
              <div class="form-group">
                <label>Business Name</label>
                <input type="text" id="businessName" required>
              </div>
              
              <div class="form-group">
                <label>Phone Number</label>
                <input type="tel" id="businessPhone" placeholder="+27...">
              </div>
              
              <div class="form-group">
                <label>Email</label>
                <input type="email" id="businessEmail">
              </div>
              
              <div class="form-group">
                <label>Currency</label>
                <select id="businessCurrency">
                  <option value="R">ZAR (R)</option>
                  <option value="$">USD ($)</option>
                  <option value="‚Ç¨">EUR (‚Ç¨)</option>
                  <option value="¬£">GBP (¬£)</option>
                </select>
              </div>
              
              <button type="submit" class="btn-primary">üíæ Save Business Info</button>
            </form>
          </div>
          
          <div class="settings-card">
            <h3>üìÖ Working Days & Schedule</h3>
            <form id="workingDaysForm">
              <p style="color: #6c757d; margin-bottom: 1rem;">Configure each day's schedule, working hours, and pay rates</p>
              
              <div class="day-settings">
                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="monday" class="day-checkbox"> <strong>Monday</strong></label>
                  </div>
                  <div class="day-details" id="mondayDetails">
                    <input type="time" id="mondayStart" value="08:00" placeholder="Start">
                    <input type="time" id="mondayEnd" value="17:00" placeholder="End">
                    <input type="number" id="mondayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>

                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="tuesday" class="day-checkbox"> <strong>Tuesday</strong></label>
                  </div>
                  <div class="day-details" id="tuesdayDetails">
                    <input type="time" id="tuesdayStart" value="08:00" placeholder="Start">
                    <input type="time" id="tuesdayEnd" value="17:00" placeholder="End">
                    <input type="number" id="tuesdayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>

                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="wednesday" class="day-checkbox"> <strong>Wednesday</strong></label>
                  </div>
                  <div class="day-details" id="wednesdayDetails">
                    <input type="time" id="wednesdayStart" value="08:00" placeholder="Start">
                    <input type="time" id="wednesdayEnd" value="17:00" placeholder="End">
                    <input type="number" id="wednesdayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>

                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="thursday" class="day-checkbox"> <strong>Thursday</strong></label>
                  </div>
                  <div class="day-details" id="thursdayDetails">
                    <input type="time" id="thursdayStart" value="08:00" placeholder="Start">
                    <input type="time" id="thursdayEnd" value="17:00" placeholder="End">
                    <input type="number" id="thursdayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>

                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="friday" class="day-checkbox"> <strong>Friday</strong></label>
                  </div>
                  <div class="day-details" id="fridayDetails">
                    <input type="time" id="fridayStart" value="08:00" placeholder="Start">
                    <input type="time" id="fridayEnd" value="17:00" placeholder="End">
                    <input type="number" id="fridayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>

                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="saturday" class="day-checkbox"> <strong>Saturday</strong></label>
                  </div>
                  <div class="day-details" id="saturdayDetails">
                    <input type="time" id="saturdayStart" value="08:00" placeholder="Start">
                    <input type="time" id="saturdayEnd" value="14:30" placeholder="End">
                    <input type="number" id="saturdayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>

                <div class="day-config">
                  <div class="day-header">
                    <label><input type="checkbox" id="sunday" class="day-checkbox"> <strong>Sunday</strong></label>
                  </div>
                  <div class="day-details" id="sundayDetails">
                    <input type="time" id="sundayStart" value="08:00" placeholder="Start">
                    <input type="time" id="sundayEnd" value="17:00" placeholder="End">
                    <input type="number" id="sundayRate" step="0.01" min="0" placeholder="Pay Rate/hr">
                  </div>
                </div>
              </div>
              
              <button type="submit" class="btn-primary">üíæ Save Working Schedule</button>
            </form>
          </div>
          
          <div class="settings-card">
            <h3>üéâ Public Holidays</h3>
            <form id="publicHolidaysForm">
              <div class="form-group">
                <label>Public Holidays (YYYY-MM-DD, one per line)</label>
                <textarea id="publicHolidays" rows="6" placeholder="2026-01-01&#10;2026-03-21&#10;2026-04-18&#10;2026-04-19&#10;2026-04-27"></textarea>
                <small>Add dates when business is closed (no work, no pay calculations)</small>
              </div>
              
              <button type="submit" class="btn-primary">üíæ Save Holidays</button>
            </form>
          </div>
          
          <div class="settings-card">
            <h3>‚è∞ Default Working Hours</h3>
            <form id="workingHoursForm">
              <div class="form-group">
                <label>Break Duration (minutes)</label>
                <input type="number" id="breakDuration" value="60" min="0">
                <small>Unpaid break time deducted from daily hours</small>
              </div>
              
              <div class="form-group">
                <label>Overtime Calculation</label>
                <select id="overtimeRule">
                  <option value="none">No Overtime</option>
                  <option value="daily">Daily (over scheduled hours)</option>
                  <option value="weekly">Weekly (over 40 hours)</option>
                </select>
              </div>
              
              <div class="form-group">
                <label>Overtime Rate Multiplier</label>
                <input type="number" id="overtimeMultiplier" value="1.5" step="0.1" min="1">
                <small>e.g., 1.5 = time and a half</small>
              </div>
              
              <button type="submit" class="btn-primary">üíæ Save Working Hours</button>
            </form>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Global switchModule function available immediately for onclick handlers
    window.switchModule = function(module) {
      console.log('Global switchModule called with:', module);
      
      try {
        // Update menu
        document.querySelectorAll('.menu-btn').forEach(btn => {
          btn.classList.remove('active');
          if (btn.dataset.module === module) {
            btn.classList.add('active');
          }
        });

        // Update view
        document.querySelectorAll('.view-section').forEach(view => {
          view.classList.remove('active');
        });
        
        let viewId = module + 'View';
        if (module === 'dashboard') viewId = 'dashboardView';
        if (module === 'monitor') viewId = 'monitorView';
        if (module === 'settings') viewId = 'settingsView';
        if (module === 'employees') viewId = 'employeesView';
        if (module === 'timecard') viewId = 'timecardView';
        if (module === 'punches') viewId = 'punchesView';
        if (module === 'sync') viewId = 'syncView';
        if (module === 'reports') viewId = 'reportsView';
        if (module === 'attendance') viewId = 'attendanceView';
        // Modules that use dashboardView container
        if (module === 'downloads') {
          viewId = 'dashboardView';
        }
        
        const view = document.getElementById(viewId);
        if (view) {
          view.classList.add('active');
          console.log('Switched to view:', viewId);
        } else {
          console.error('View not found:', viewId);
        }

        // Call module-specific loading function
        if (window.loadModuleData) {
          if (module === 'monitor') {
            if (window.loadMonitorData) window.loadMonitorData();
          } else {
            window.loadModuleData(module);
          }
        }
        
      } catch (error) {
        console.error('Error in global switchModule:', error);
      }
    };
  </script>

  <script type="module">
    import authService from '../modules/auth/auth.service.js';
    import { doc, getDoc, collection, getDocs, addDoc, setDoc, deleteDoc, onSnapshot, query, where, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { db } from '../config/firebase.js';

    let businessId = null;
    let pollingInterval = null;
    let statusUnsubscribe = null;

    // Placeholder functions for global access
    window.loadModuleData = async function(module) {
      console.log('Global loadModuleData placeholder called:', module);
    };
    
    window.loadMonitorData = function() {
      console.log('Global loadMonitorData placeholder called');
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initDashboard();
    });

    async function initDashboard() {
      try {
        console.log('Initializing dashboard...');
        
        // Check authentication
        if (!authService.isAuthenticated() || authService.getUserRole() !== "business") {
          console.log('Authentication failed, redirecting to login');
          window.location.href = '/pages/login.html';
          return;
        }

        businessId = authService.getBusinessId();
        console.log('Business ID:', businessId);
        
        const businessName = sessionStorage.getItem("businessName");
        const userEmail = sessionStorage.getItem("userEmail") || sessionStorage.getItem("businessId");
        
        console.log('Business Name:', businessName);
        console.log('User Email:', userEmail);
        
        // Update UI elements
        const businessNameEl = document.getElementById('businessName');
        const userEmailEl = document.getElementById('userEmail');
        
        if (businessNameEl) {
          businessNameEl.textContent = businessName || "Business Dashboard";
        }
        if (userEmailEl) {
          userEmailEl.textContent = userEmail;
        }

        console.log('Setting up event listeners...');
        setupEventListeners();
        
        console.log('Loading dashboard data...');
        await loadDashboardData();
        
        console.log('Setting up realtime listeners...');
        setupRealtimeListeners();
        
        console.log('Dashboard initialized successfully');
        
      } catch (error) {
        console.error('Error initializing dashboard:', error);
        // Show error message to user
        const loadingEl = document.querySelector('.section-description');
        if (loadingEl && loadingEl.textContent === 'Loading...') {
          loadingEl.textContent = `Error loading dashboard: ${error.message}`;
          loadingEl.style.color = '#dc3545';
        }
        
        // Still try to setup event listeners even if other things fail
        try {
          setupEventListeners();
        } catch (listenerError) {
          console.error('Error setting up event listeners:', listenerError);
        }
      }
    }

    function setupRealtimeListeners() {
      // Setup real-time listener for status collection
      const statusRef = collection(db, "businesses", businessId, "status");
      statusUnsubscribe = onSnapshot(statusRef, (snapshot) => {
        console.log("Status update received from Firebase");
        // Only update if monitor view is active
        if (document.querySelector('.menu-btn[data-module="monitor"].active')) {
          loadMonitorData();
        }
      }, (error) => {
        console.error("Error listening to status:", error);
      });
    }

    function setupEventListeners() {
      try {
        console.log('Setting up menu button listeners...');
        
        // Menu buttons - only select buttons with data-module attribute
        const menuButtons = document.querySelectorAll('.menu-btn[data-module]');
        console.log('Found', menuButtons.length, 'menu buttons');
        
        menuButtons.forEach((btn, index) => {
          const module = btn.dataset.module;
          console.log(`Setting up listener for button ${index}:`, module);
          
          btn.addEventListener('click', function(e) {
            console.log('Menu button clicked:', module);
            e.preventDefault();
            switchModule(module);
          });
        });

        // Module cards
        const moduleCards = document.querySelectorAll('.module-card[data-module]');
        console.log('Found', moduleCards.length, 'module cards');
        
        moduleCards.forEach(card => {
          card.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const module = this.dataset.module;
            console.log('Module card clicked:', module);
            
            // Add visual feedback
            this.style.transform = 'scale(0.95)';
            setTimeout(() => {
              this.style.transform = 'scale(1)';
            }, 150);
            
            switchModule(module);
          });
          
          // Add cursor pointer style
          card.style.cursor = 'pointer';
        });

        // Logout
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) {
          logoutBtn.addEventListener('click', async () => {
            if (pollingInterval) clearInterval(pollingInterval);
            if (statusUnsubscribe) statusUnsubscribe();
            await authService.logout();
            window.location.href = '/pages/login.html';
          });
        }

        // Refresh
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            loadDashboardData();
            loadMonitorData();
          });
        }
        
        console.log('Event listeners setup completed successfully');
        window.listenersSetup = true;
        
      } catch (error) {
        console.error('Error in setupEventListeners:', error);
      }
    }

    function switchModule(module) {
      console.log('Switching to module:', module);
      
      // Update menu
      document.querySelectorAll('.menu-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.module === module) {
          btn.classList.add('active');
        }
      });

      // Update view
      document.querySelectorAll('.view-section').forEach(view => {
        view.classList.remove('active');
      });
      
      // Map modules to their corresponding view IDs
      const moduleViewMap = {
        'dashboard': 'dashboardView',
        'monitor': 'monitorView',
        'attendance': 'attendanceView',
        'timecard': 'timecardView',
        'reports': 'reportsView',
        'employees': 'employeesView',
        'punches': 'punchesView',
        'sync': 'syncView',
        'sql-integration': 'sqlIntegrationView',
        'settings': 'settingsView',
        'downloads': 'syncView'  // Use sync view for downloads until we have a dedicated view
      };
      
      const viewId = moduleViewMap[module] || 'dashboardView';
      console.log('Switching to view:', viewId);
      
      const view = document.getElementById(viewId);
      if (view) {
        view.classList.add('active');
        console.log('View switched successfully');
      } else {
        console.error('View not found:', viewId);
      }

      if (module === 'monitor') {
        loadMonitorData();
      } else {
        loadModuleData(module);
      }
    }

    async function loadDashboardData() {
      try {
        const businessRef = doc(db, "businesses", businessId);
        const businessDoc = await getDoc(businessRef);

        if (businessDoc.exists()) {
          const data = businessDoc.data();
          const planName = data.plan || 'Basic';
          document.getElementById('planStatus').textContent = planName;
          
          // Get plan limits
          const planLimits = {
            'Basic': 5,
            'Standard': 10,
            'Professional': 20,
            'Premium': 30,
            'Enterprise': 50
          };
          // Use slotsAllowed as primary source, fall back to maxEmployees or plan limits
          const maxSlots = data.slotsAllowed || data.maxEmployees || planLimits[planName] || 20;
          
          // Load staff to count active employees (only within slot limits)
          const staffRef = collection(db, "businesses", businessId, "staff");
          const staffSnap = await getDocs(staffRef);
          
          // Only count employees within the allowed slot range
          const validActiveEmployees = Array.from(staffSnap.docs).filter(doc => {
            const staff = doc.data();
            const slot = parseInt(staff.slot || doc.id);
            return staff.active && slot >= 1 && slot <= maxSlots;
          });
          const activeCount = validActiveEmployees.length;
          
          // Load status to count present today (only for valid employees)
          const statusRef = collection(db, "businesses", businessId, "status");
          const statusSnap = await getDocs(statusRef);
          
          const validEmployeeIds = validActiveEmployees.map(doc => doc.id);
          const presentCount = Array.from(statusSnap.docs).filter(doc => {
            const status = doc.data();
            return validEmployeeIds.includes(doc.id) && 
                   status.attendanceStatus === 'in' && 
                   status.lastClockTime;
          }).length;
          
          document.getElementById('activeEmployees').textContent = activeCount;
          document.getElementById('presentToday').textContent = presentCount;
          document.getElementById('slotsText').textContent = `Out of ${maxSlots} slots`;
          
          // Calculate attendance rate
          const attendanceRate = activeCount > 0 ? Math.round((presentCount / activeCount) * 100) : 0;
          document.getElementById('attendanceRate').textContent = attendanceRate + '%';
        }
      } catch (error) {
        console.error("Error loading dashboard data:", error);
      }
    }

    async function loadMonitorData() {
      try {
        console.log("Loading monitor data for business:", businessId);
        
        const statusRef = collection(db, "businesses", businessId, "status");
        const statusSnap = await getDocs(statusRef);
        
        console.log("Retrieved status documents:", statusSnap.size);
        
        let inEmployees = [];
        let outEmployees = [];
        
        statusSnap.forEach(doc => {
          const status = doc.data();
          console.log("Processing employee:", status.employeeName, "attendanceStatus:", status.attendanceStatus);
          
          // Only show employees who have actually clocked in at some point (have lastClockTime)
          // This filters out unused slots that were auto-created
          if (!status.lastClockTime) {
            console.log("Skipping unused slot:", status.employeeName);
            return;
          }
          
          // Check attendanceStatus field for IN/OUT
          if (status.attendanceStatus === 'in') {
            inEmployees.push(status);
          } else {
            outEmployees.push(status);
          }
        });

        console.log("IN employees:", inEmployees.length);
        console.log("OUT employees:", outEmployees.length);

        // Render IN employees
        let inHtml = '';
        if (inEmployees.length === 0) {
          inHtml = '<div class="no-employees">No employees clocked in</div>';
        } else {
          inEmployees.forEach(emp => {
            const slotDisplay = emp.slot || emp.slotNumber || emp.employeeId || 'N/A';
            const lastTime = emp.lastClockTime ? new Date(emp.lastClockTime).toLocaleTimeString() : 'N/A';
            inHtml += `
              <div class="employee-item">
                <div>
                  <div class="employee-name">${emp.employeeName}</div>
                  <div class="employee-slot">SLOT ${slotDisplay}</div>
                </div>
                <div class="employee-time">${lastTime}</div>
              </div>
            `;
          });
        }
        document.getElementById('inEmployees').innerHTML = inHtml;

        // Render OUT employees
        let outHtml = '';
        if (outEmployees.length === 0) {
          outHtml = '<div class="no-employees">No employees clocked out</div>';
        } else {
          outEmployees.forEach(emp => {
            const slotDisplay = emp.slot || emp.slotNumber || emp.employeeId || 'N/A';
            const lastTime = emp.lastClockTime ? new Date(emp.lastClockTime).toLocaleTimeString() : 'N/A';
            outHtml += `
              <div class="employee-item">
                <div>
                  <div class="employee-name">${emp.employeeName}</div>
                  <div class="employee-slot">SLOT ${slotDisplay}</div>
                </div>
                <div class="employee-time">${lastTime}</div>
              </div>
            `;
          });
        }
        document.getElementById('outEmployees').innerHTML = outHtml;

        // Update timestamp
        const now = new Date();
        const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
        document.getElementById('lastUpdateTime').textContent = timeStr;

      } catch (error) {
        console.error("Error loading monitor data:", error);
        console.error("Error code:", error.code);
        const errorMsg = error.code === 'permission-denied' ? 'Permission denied - check Firestore rules' : error.message;
        document.getElementById('inEmployees').innerHTML = '<div class="no-employees" style="color: #c33;">Error: ' + errorMsg + '</div>';
        document.getElementById('outEmployees').innerHTML = '<div class="no-employees"></div>';
      }
    }

    // Update global reference to loadMonitorData
    window.loadMonitorData = loadMonitorData;

    function formatDuration(timestamp) {
      // Format as HH:MM:SS
      const date = new Date(timestamp);
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }

    async function loadModuleData(module) {
      console.log('Loading module:', module);
      
      try {
        if (module === 'employees') {
          console.log('Loading employees module...');
          await loadEmployees();
          return;
        }
        
        if (module === 'timecard') {
          console.log('Loading timecard module...');
          await initTimecard();
          return;
        }
        
        if (module === 'punches') {
          console.log('Loading punches module...');
          await initPunches();
          return;
        }
        
        if (module === 'sync') {
          console.log('Loading sync module...');
          await initDeviceSync();
          return;
        }
        
        if (module === 'reports') {
          console.log('Loading reports module...');
          await initReports();
          return;
        }

        if (module === 'downloads') {
          console.log('Loading downloads module...');
          await loadDownloads();
          return;
        }
        
        if (module === 'settings') {
          console.log('Loading settings module...');
          await loadSettings();
          return;
        }
        
        console.log('Module loaded successfully:', module);
        
      } catch (error) {
        console.error('Error loading module', module, ':', error);
        // Don't break other modules
      }
      
      const contentIds = {
        'attendance': 'attendanceContent'
      };

      const contentId = contentIds[module];
      if (contentId) {
        const content = document.getElementById(contentId);
        if (content) {
          setTimeout(() => {
            content.innerHTML = `<p style="color: #999;">Module content for ${module} will be displayed here</p>`;
          }, 500);
        }
      }
    }

    // Update global reference to loadModuleData
    window.loadModuleData = loadModuleData;

    async function loadEmployees() {
      try {
        const employeesGrid = document.getElementById('employeesGrid');
        const employeeCountEl = document.getElementById('employeeCount');
        employeesGrid.innerHTML = '<div style="text-align: center; padding: 2rem; color: #999;">Loading employees...</div>';

        // Load all staff and status data
        const staffRef = collection(db, "businesses", businessId, "staff");
        const statusRef = collection(db, "businesses", businessId, "status");
        
        const [staffSnap, statusSnap] = await Promise.all([
          getDocs(staffRef),
          getDocs(statusRef)
        ]);

        // Create a map of current statuses
        const statusMap = new Map();
        statusSnap.forEach(doc => {
          const status = doc.data();
          statusMap.set(doc.id, status);
        });

        // Create employee data map by slot
        const employeeSlots = new Map();
        
        // Get business settings first to determine slot limits
        const businessRef = doc(db, "businesses", businessId);
        const businessDoc = await getDoc(businessRef);
        const businessData = businessDoc.exists() ? businessDoc.data() : {};
        
        const planLimits = {
          'Basic': 5,
          'Standard': 10,
          'Professional': 20,
          'Premium': 30,
          'Enterprise': 50
        };
        
        const planName = businessData.plan || 'Professional';
        // Use slotsAllowed as primary source, fall back to maxEmployees or plan limits
        const maxSlots = businessData.slotsAllowed || businessData.maxEmployees || planLimits[planName] || 20;
        
        console.log('Dashboard Debug:', {
          slotsAllowed: businessData.slotsAllowed,
          maxEmployees: businessData.maxEmployees,
          planName: planName,
          finalMaxSlots: maxSlots
        });
        
        // Only count employees within the allowed slot range
        const validEmployees = [];
        
        staffSnap.forEach(doc => {
          const staff = doc.data();
          const status = statusMap.get(doc.id);
          const slot = parseInt(staff.slot || doc.id);
          
          // Only include employees within the slot limit
          if (slot >= 1 && slot <= maxSlots) {
            const employeeData = {
              id: doc.id,
              ...staff,
              currentStatus: status?.attendanceStatus || 'unknown',
              lastClockTime: status?.lastClockTime || null,
              hasEverClockedIn: !!status?.lastClockTime
            };
            
            employeeSlots.set(slot, employeeData);
            validEmployees.push(employeeData);
          }
        });

        const slotCards = [];
        for (let i = 1; i <= maxSlots; i++) {
          const employee = employeeSlots.get(i);
          
          if (employee) {
            // Occupied slot
            const isIn = employee.currentStatus === 'in';
            const statusClass = isIn ? 'clocked-in' : 'clocked-out';
            const statusText = isIn ? '‚óè Clocked In' : '‚óã Clocked Out';
            const lastTime = employee.lastClockTime ? new Date(employee.lastClockTime).toLocaleString() : 'Never clocked in';
            
            slotCards.push(`
              <div class="employee-card ${employee.active ? '' : 'inactive'}">
                <div class="employee-header">
                  <div class="employee-info">
                    <h3>${employee.employeeName || 'Unnamed Employee'}</h3>
                    <div class="employee-status ${statusClass}">${statusText}</div>
                  </div>
                  <span class="employee-slot-badge">SLOT ${i}</span>
                </div>
                
                <div class="employee-details">
                  <div class="employee-detail-row">
                    <span class="detail-label">Employee ID:</span>
                    <span class="detail-value">${employee.employeeId || employee.id}</span>
                  </div>
                  <div class="employee-detail-row">
                    <span class="detail-label">Badge Number:</span>
                    <span class="detail-value">${employee.badgeNumber || 'N/A'}</span>
                  </div>
                  <div class="employee-detail-row">
                    <span class="detail-label">Phone:</span>
                    <span class="detail-value">${employee.phone || 'Not set'}</span>
                  </div>
                  <div class="employee-detail-row">
                    <span class="detail-label">Email:</span>
                    <span class="detail-value">${employee.email || 'Not set'}</span>
                  </div>
                  <div class="employee-detail-row">
                    <span class="detail-label">Position:</span>
                    <span class="detail-value">${employee.position || 'Not set'}</span>
                  </div>
                  <div class="employee-detail-row">
                    <span class="detail-label">Last Clock:</span>
                    <span class="detail-value">${lastTime}</span>
                  </div>
                </div>
                
                <div class="employee-actions">
                  <button class="btn-edit" onclick="editEmployee('${employee.id}')">‚úèÔ∏è Edit Details</button>
                  <button class="btn-view" onclick="viewEmployeeHistory('${employee.id}')">üìä View History</button>
                  ${!employee.hasEverClockedIn ? `
                    <button class="btn-setup" onclick="initializeEmployeeSlot('${employee.id}', '${employee.employeeName}', ${i})" 
                            style="background: #17a2b8; color: white; width: 100%; margin-top: 0.5rem;">
                      üöÄ Initialize Slot (First Time Punch)
                    </button>
                  ` : ''}
                </div>
              </div>
            `);
          } else {
            // Empty slot
            slotCards.push(`
              <div class="employee-card empty-slot">
                <div class="employee-header">
                  <div class="employee-info">
                    <h3 style="color: #999;">Empty Slot</h3>
                    <div class="employee-status" style="color: #999;">‚óè Available</div>
                  </div>
                  <span class="employee-slot-badge empty">SLOT ${i}</span>
                </div>
                
                <div class="employee-details">
                  <div class="empty-slot-message">
                    <p style="color: #666; text-align: center; margin: 1rem 0;">
                      This slot is available for a new employee
                    </p>
                  </div>
                </div>
                
                <div class="employee-actions">
                  <button class="btn-add" onclick="assignEmployeeToSlot(${i})" style="background: #28a745; color: white; width: 100%;">
                    ‚ûï Add Employee to Slot ${i}
                  </button>
                </div>
              </div>
            `);
          }
        }

        // Update counts and render
        const occupiedSlots = validEmployees.length;
        const availableSlots = maxSlots - occupiedSlots;
        employeeCountEl.innerHTML = `${occupiedSlots} of ${maxSlots} slots occupied ‚Ä¢ ${availableSlots} slots available`;
        
        if (slotCards.length === 0) {
          employeesGrid.innerHTML = '<div class="no-employees">No employee slots configured.</div>';
          return;
        }

        employeesGrid.innerHTML = slotCards.join('');

      } catch (error) {
        console.error("Error loading employees:", error);
        document.getElementById('employeesGrid').innerHTML = 
          '<div class="no-employees" style="color: #e53e3e;">Error loading employees: ' + error.message + '</div>';
      }
    }

    async function editEmployee(employeeId) {
      try {
        const staffRef = doc(db, "businesses", businessId, "staff", employeeId);
        const staffDoc = await getDoc(staffRef);
        
        if (!staffDoc.exists()) {
          alert('Employee not found');
          return;
        }

        const emp = staffDoc.data();
        
        const modal = `
          <div class="modal-overlay" onclick="closeModal(event)">
            <div class="modal-employee" onclick="event.stopPropagation()">
              <h2>Edit Employee Details</h2>
              <form id="employeeEditForm" onsubmit="saveEmployee(event, '${employeeId}')">
                <div class="form-group">
                  <label>Employee Name*</label>
                  <input type="text" name="employeeName" value="${emp.employeeName || ''}" required>
                </div>
                
                <div class="form-group">
                  <label>Slot Number</label>
                  <input type="text" name="slot" value="${emp.slot || ''}" readonly>
                </div>
                
                <div class="form-group">
                  <label>Badge Number</label>
                  <input type="text" name="badgeNumber" value="${emp.badgeNumber || ''}" readonly>
                </div>
                
                <div class="form-group">
                  <label>Phone Number</label>
                  <input type="tel" name="phone" value="${emp.phone || ''}" placeholder="+27 XX XXX XXXX">
                </div>
                
                <div class="form-group">
                  <label>Email Address</label>
                  <input type="email" name="email" value="${emp.email || ''}" placeholder="employee@example.com">
                </div>
                
                <div class="form-group">
                  <label>Position/Title</label>
                  <input type="text" name="position" value="${emp.position || ''}" placeholder="e.g., Technician, Manager">
                </div>
                
                <div class="form-group">
                  <label>Department</label>
                  <input type="text" name="department" value="${emp.department || ''}" placeholder="e.g., Production, Sales">
                </div>
                
                <div class="form-group">
                  <label>ID Number</label>
                  <input type="text" name="idNumber" value="${emp.idNumber || ''}" placeholder="SA ID Number">
                </div>
                
                <div class="form-group">
                  <label>Address</label>
                  <textarea name="address" placeholder="Full address">${emp.address || ''}</textarea>
                </div>
                
                <div class="form-group">
                  <label>Hire Date</label>
                  <input type="date" name="hireDate" value="${emp.hireDate || ''}">
                </div>
                
                <div class="form-group">
                  <label>Hourly Rate (ZAR)</label>
                  <input type="number" name="hourlyRate" value="${emp.hourlyRate || ''}" step="0.01" placeholder="0.00">
                </div>
                
                <div class="form-group">
                  <label>Notes</label>
                  <textarea name="notes" placeholder="Additional notes or comments">${emp.notes || ''}</textarea>
                </div>
                
                <div class="modal-actions">
                  <button type="button" class="btn-cancel" onclick="closeModal()">Cancel</button>
                  <button type="submit" class="btn-save">üíæ Save Changes</button>
                </div>
              </form>
            </div>
          </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modal);
        
      } catch (error) {
        console.error("Error editing employee:", error);
        alert('Error: ' + error.message);
      }
    }

    async function saveEmployee(event, employeeId) {
      event.preventDefault();
      
      try {
        const form = event.target;
        const formData = new FormData(form);
        
        const employeeData = {
          employeeName: formData.get('employeeName'),
          phone: formData.get('phone'),
          email: formData.get('email'),
          position: formData.get('position'),
          department: formData.get('department'),
          idNumber: formData.get('idNumber'),
          address: formData.get('address'),
          hireDate: formData.get('hireDate'),
          hourlyRate: parseFloat(formData.get('hourlyRate')) || 0,
          notes: formData.get('notes'),
          updatedAt: new Date().toISOString()
        };
        
        // Update Firebase
        const staffRef = doc(db, "businesses", businessId, "staff", employeeId);
        await setDoc(staffRef, employeeData, { merge: true });
        
        console.log("Employee updated successfully");
        
        // Close modal
        closeModal();
        
        // Reload employees
        await loadEmployees();
        
        alert('Employee details updated successfully!');
        
      } catch (error) {
        console.error("Error saving employee:", error);
        alert('Error saving: ' + error.message);
      }
    }

    function closeModal(event) {
      if (event && event.target.classList.contains('modal-overlay')) {
        event.target.remove();
      } else {
        document.querySelector('.modal-overlay')?.remove();
      }
    }

    async function viewEmployeeHistory(employeeId) {
      alert('Employee history view coming soon!');
      // TODO: Implement attendance history view
    }

    // Add New Employee Function
    async function addNewEmployee() {
      const modal = `
        <div class="modal-overlay" onclick="closeModal(event)">
          <div class="modal-employee" onclick="event.stopPropagation()">
            <h2>Add New Employee</h2>
            <form id="employeeAddForm" onsubmit="saveNewEmployee(event)">
              <div class="form-group">
                <label>Employee Name*</label>
                <input type="text" name="employeeName" required placeholder="Enter full name">
              </div>
              
              <div class="form-group">
                <label>Slot Number*</label>
                <select name="slot" required>
                  <option value="">Select available slot</option>
                </select>
              </div>
              
              <div class="form-group">
                <label>Badge Number</label>
                <input type="text" name="badgeNumber" placeholder="Badge or card number">
              </div>
              
              <div class="form-group">
                <label>Phone Number</label>
                <input type="tel" name="phone" placeholder="+27 XX XXX XXXX">
              </div>
              
              <div class="form-group">
                <label>Email Address</label>
                <input type="email" name="email" placeholder="employee@example.com">
              </div>
              
              <div class="form-group">
                <label>Position/Title</label>
                <input type="text" name="position" placeholder="e.g., Technician, Manager">
              </div>
              
              <div class="form-group">
                <label>Department</label>
                <input type="text" name="department" placeholder="e.g., Production, Sales">
              </div>
              
              <div class="form-group">
                <label>ID Number</label>
                <input type="text" name="idNumber" placeholder="SA ID Number">
              </div>
              
              <div class="form-group">
                <label>Hourly Rate (ZAR)</label>
                <input type="number" name="hourlyRate" step="0.01" placeholder="0.00">
              </div>
              
              <div class="modal-buttons">
                <button type="button" onclick="closeModal()" class="btn-secondary">Cancel</button>
                <button type="submit" class="btn-primary">Add Employee</button>
              </div>
            </form>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modal);
      
      // Load available slots
      await loadAvailableSlots();
    }

    // Assign Employee to Specific Slot
    async function assignEmployeeToSlot(slotNumber) {
      const modal = `
        <div class="modal-overlay" onclick="closeModal(event)">
          <div class="modal-employee" onclick="event.stopPropagation()">
            <h2>Add Employee to Slot ${slotNumber}</h2>
            <form id="employeeAssignForm" onsubmit="saveSlotEmployee(event, ${slotNumber})">
              <div class="form-group">
                <label>Employee Name*</label>
                <input type="text" name="employeeName" required placeholder="Enter full name">
              </div>
              
              <div class="form-group">
                <label>Slot Number</label>
                <input type="text" name="slot" value="${slotNumber}" readonly style="background: #f5f5f5;">
              </div>
              
              <div class="form-group">
                <label>Badge Number</label>
                <input type="text" name="badgeNumber" placeholder="Badge or card number">
              </div>
              
              <div class="form-group">
                <label>Phone Number</label>
                <input type="tel" name="phone" placeholder="+27 XX XXX XXXX">
              </div>
              
              <div class="form-group">
                <label>Email Address</label>
                <input type="email" name="email" placeholder="employee@example.com">
              </div>
              
              <div class="form-group">
                <label>Position/Title</label>
                <input type="text" name="position" placeholder="e.g., Technician, Manager">
              </div>
              
              <div class="form-group">
                <label style="display: flex; align-items: center; gap: 0.5rem;">
                  <input type="checkbox" name="doFirstPunch" id="doFirstPunch_${slotNumber}" checked>
                  <span>Perform First Time Punch (Initialize slot without device)</span>
                </label>
                <small style="color: #666; margin-left: 1.5rem;">
                  This will populate the employee slot data and mark them as "clocked out" so they can start using the system immediately.
                </small>
              </div>
              
              <div class="modal-buttons">
                <button type="button" onclick="closeModal()" class="btn-secondary">Cancel</button>
                <button type="submit" class="btn-primary">Add to Slot ${slotNumber}</button>
              </div>
            </form>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modal);
    }

    // Load available slots for dropdown
    async function loadAvailableSlots() {
      try {
        // Get business plan info
        const businessRef = doc(db, "businesses", businessId);
        const businessDoc = await getDoc(businessRef);
        const businessData = businessDoc.exists() ? businessDoc.data() : {};
        
        const planLimits = {
          'Basic': 5,
          'Standard': 10,
          'Professional': 20,
          'Premium': 30,
          'Enterprise': 50
        };
        
        const planName = businessData.plan || 'Professional';
        const maxSlots = businessData.maxEmployees || planLimits[planName] || 20;
        
        const staffRef = collection(db, "businesses", businessId, "staff");
        const staffSnap = await getDocs(staffRef);
        
        const occupiedSlots = new Set();
        staffSnap.forEach(doc => {
          const staff = doc.data();
          if (staff.slot) {
            occupiedSlots.add(parseInt(staff.slot));
          }
        });

        const slotSelect = document.querySelector('select[name="slot"]');
        slotSelect.innerHTML = '<option value="">Select available slot</option>';
        
        for (let i = 1; i <= maxSlots; i++) {
          if (!occupiedSlots.has(i)) {
            slotSelect.innerHTML += `<option value="${i}">Slot ${i}</option>`;
          }
        }

      } catch (error) {
        console.error("Error loading available slots:", error);
      }
    }

    // Save new employee
    async function saveNewEmployee(event) {
      event.preventDefault();
      
      const formData = new FormData(event.target);
      const employeeData = {};
      
      for (let [key, value] of formData.entries()) {
        if (value.trim()) {
          employeeData[key] = value.trim();
        }
      }

      if (!employeeData.employeeName || !employeeData.slot) {
        alert('Employee name and slot are required!');
        return;
      }

      try {
        const slotId = employeeData.slot;
        delete employeeData.slot;

        employeeData.slot = parseInt(slotId);
        employeeData.employeeId = slotId;
        employeeData.active = true;
        employeeData.createdAt = new Date().toISOString();

        const staffRef = doc(db, "businesses", businessId, "staff", slotId);
        await setDoc(staffRef, employeeData);

        closeModal();
        await loadEmployees();
        
        alert(`Employee ${employeeData.employeeName} added to Slot ${slotId} successfully!`);
        
      } catch (error) {
        console.error("Error adding employee:", error);
        alert('Error adding employee: ' + error.message);
      }
    }

    // Save employee to specific slot
    async function saveSlotEmployee(event, slotNumber) {
      event.preventDefault();
      
      const formData = new FormData(event.target);
      const employeeData = {};
      
      for (let [key, value] of formData.entries()) {
        if (value.trim()) {
          employeeData[key] = value.trim();
        }
      }

      if (!employeeData.employeeName) {
        alert('Employee name is required!');
        return;
      }

      try {
        employeeData.slot = slotNumber;
        employeeData.employeeId = slotNumber.toString();
        employeeData.active = true;
        employeeData.createdAt = new Date().toISOString();

        // Save employee to staff collection
        const staffRef = doc(db, "businesses", businessId, "staff", slotNumber.toString());
        await setDoc(staffRef, employeeData);

        // Check if user wants to do first-time punch
        const doFirstPunch = formData.get('doFirstPunch') === 'on';
        
        if (doFirstPunch) {
          console.log('Performing first-time punch for employee:', employeeData.employeeName);
          
          // Perform initial "clock out" punch via webhook to initialize the slot
          const webhookPayload = {
            deviceId: 'SETUP',
            verifyNo: slotNumber.toString(),
            employeeName: employeeData.employeeName,
            attendanceStatus: 'out', // Start as clocked out
            timestamp: new Date().toISOString(),
            businessId: businessId,
            isManual: true,
            manualNotes: 'Initial setup punch - employee slot initialized',
            isFirstTimeSetup: true
          };

          try {
            const webhookResponse = await fetch('https://attendancewebhook-4q7htrps4q-uc.a.run.app', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(webhookPayload)
            });

            const webhookResult = await webhookResponse.json();
            
            if (webhookResult.success) {
              console.log('First-time punch completed successfully');
            } else {
              console.warn('First-time punch failed:', webhookResult.error);
              alert('Employee added but first-time punch failed: ' + webhookResult.error);
            }
          } catch (webhookError) {
            console.error('Error performing first-time punch:', webhookError);
            alert('Employee added but first-time punch failed. They may need to punch on the device first.');
          }
        }

        closeModal();
        await loadEmployees();
        
        const successMessage = doFirstPunch 
          ? `Employee ${employeeData.employeeName} added to Slot ${slotNumber} and initialized with first-time punch!`
          : `Employee ${employeeData.employeeName} added to Slot ${slotNumber} successfully!`;
        
        alert(successMessage);
        
      } catch (error) {
        console.error("Error adding employee:", error);
        alert('Error adding employee: ' + error.message);
      }
    }

    // Initialize employee slot with first-time punch
    async function initializeEmployeeSlot(employeeId, employeeName, slotNumber) {
      const confirmed = confirm(`Initialize slot for ${employeeName}?\n\nThis will:\n‚Ä¢ Set them as "clocked out" status\n‚Ä¢ Initialize their attendance system\n‚Ä¢ Allow them to start using the time clock\n\nNote: This is the same as doing their first punch on the device.`);
      
      if (!confirmed) return;

      try {
        console.log('Initializing employee slot:', { employeeId, employeeName, slotNumber });
        
        // Perform initial "clock out" punch via webhook to initialize the slot
        const webhookPayload = {
          deviceId: 'INITIALIZE',
          verifyNo: slotNumber.toString(),
          employeeName: employeeName,
          attendanceStatus: 'out', // Start as clocked out
          timestamp: new Date().toISOString(),
          businessId: businessId,
          isManual: true,
          manualNotes: 'Slot initialization - first-time setup from admin panel',
          isFirstTimeSetup: true
        };

        const webhookResponse = await fetch('https://attendancewebhook-4q7htrps4q-uc.a.run.app', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(webhookPayload)
        });

        const webhookResult = await webhookResponse.json();
        
        if (webhookResult.success) {
          alert(`Slot initialized successfully for ${employeeName}!\n\nThey can now clock in/out using the device or manual punch.`);
          await loadEmployees(); // Refresh to show updated status
        } else {
          alert('Initialization failed: ' + webhookResult.error);
        }
        
      } catch (error) {
        console.error('Error initializing slot:', error);
        alert('Error initializing slot: ' + error.message);
      }
    }

    // Debug function to check data structure
    window.debugPunchData = async function() {
      console.log('=== DEBUG PUNCH DATA STRUCTURE ===');
      console.log('Business ID:', businessId);
      const today = new Date().toISOString().split('T')[0];
      console.log('Today:', today);
      
      try {
        // Check if attendance_events collection exists
        const attendanceRef = collection(db, "businesses", businessId, "attendance_events");
        const attendanceSnap = await getDocs(attendanceRef);
        console.log('attendance_events documents:', attendanceSnap.size);
        
        attendanceSnap.forEach(doc => {
          console.log('Date document:', doc.id);
        });
        
        // Check specific date structure
        for (let slot = 1; slot <= 10; slot++) {
          try {
            const slotRef = collection(db, "businesses", businessId, "attendance_events", today, slot.toString());
            const slotSnap = await getDocs(slotRef);
            if (slotSnap.size > 0) {
              console.log(`Slot ${slot} has ${slotSnap.size} events`);
              slotSnap.forEach(eventDoc => {
                console.log(`  Event:`, eventDoc.data());
              });
            }
          } catch (e) {
            // Slot doesn't exist, which is normal
          }
        }
        
        // ‚úÖ UNIFIED: Check attendance_events collection (single source of truth)
        const attendanceEventsRef = collection(db, "businesses", businessId, "attendance_events");
        const eventsSnap = await getDocs(attendanceEventsRef);
        console.log('attendance_events documents:', eventsSnap.size);
        
        eventsSnap.forEach(doc => {
          console.log('Attendance event:', doc.id, doc.data());
        });
        
      } catch (error) {
        console.error('Debug error:', error);
      }
    };

    // Make functions globally available
    window.editEmployee = editEmployee;
    window.saveEmployee = saveEmployee;
    window.closeModal = closeModal;
    window.viewEmployeeHistory = viewEmployeeHistory;
    window.addNewEmployee = addNewEmployee;
    window.assignEmployeeToSlot = assignEmployeeToSlot;
    window.saveNewEmployee = saveNewEmployee;
    window.saveSlotEmployee = saveSlotEmployee;
    window.initializeEmployeeSlot = initializeEmployeeSlot;

    // ============================================
    // TIMECARD MODULE FUNCTIONS
    // ============================================
    
    async function initTimecard() {
      try {
        // Load employee list for dropdown
        const staffRef = collection(db, "businesses", businessId, "staff");
        const statusRef = collection(db, "businesses", businessId, "status");
        
        const [staffSnap, statusSnap] = await Promise.all([
          getDocs(staffRef),
          getDocs(statusRef)
        ]);

        // Create a map of employees with lastClockTime
        const statusMap = new Map();
        statusSnap.forEach(doc => {
          const status = doc.data();
          if (status.lastClockTime) {
            statusMap.set(doc.id, status);
          }
        });

        // Filter and populate employee dropdown
        const employeeSelect = document.getElementById('employeeSelect');
        employeeSelect.innerHTML = '<option value="">-- Select Employee --</option>';
        
        const employees = [];
        staffSnap.forEach(doc => {
          const staff = doc.data();
          const status = statusMap.get(doc.id);
          
          if (status && status.lastClockTime) {
            employees.push({
              id: doc.id,
              name: staff.employeeName,
              slot: staff.slot
            });
          }
        });

        // Sort by slot
        employees.sort((a, b) => (a.slot || 0) - (b.slot || 0));

        // Add to dropdown
        employees.forEach(emp => {
          const option = document.createElement('option');
          option.value = emp.id;
          option.textContent = `${emp.name} (Slot ${emp.slot || emp.id})`;
          employeeSelect.appendChild(option);
        });

        // Set default month to current month
        const now = new Date();
        const monthInput = document.getElementById('monthSelect');
        monthInput.value = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

      } catch (error) {
        console.error("Error initializing timecard:", error);
        alert('Error loading timecard: ' + error.message);
      }
    }

    async function loadTimecard() {
      // Helper function to format decimal hours to hours:minutes
      function formatHours(decimalHours) {
        const hrs = Math.floor(decimalHours);
        const mins = Math.round((decimalHours - hrs) * 60);
        return decimalHours > 0 ? (mins > 0 ? `${hrs}h ${mins}m` : `${hrs}h`) : '0h';
      }
      
      const employeeId = document.getElementById('employeeSelect').value;
      const month = document.getElementById('monthSelect').value;
      const display = document.getElementById('timecardDisplay');

      if (!employeeId || !month) {
        display.innerHTML = '<div style="text-align: center; padding: 3rem; color: #999;">Select an employee and month to view timecard</div>';
        return;
      }

      try {
        display.innerHTML = '<div style="text-align: center; padding: 3rem; color: #999;">Loading timecard...</div>';

        // Get employee info
        const staffRef = doc(db, "businesses", businessId, "staff", employeeId);
        const staffDoc = await getDoc(staffRef);
        const employee = staffDoc.data();

        // Parse month
        const [year, monthNum] = month.split('-');
        const monthDate = new Date(year, monthNum - 1, 1);
        const monthName = monthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

        // Get all days in month
        const daysInMonth = new Date(year, monthNum, 0).getDate();
        const dailyRecords = [];

        // Get business schedule and settings
        const businessRef = doc(db, "businesses", businessId);
        const businessDoc = await getDoc(businessRef);
        const businessData = businessDoc.data();
        const schedule = businessData?.schedule || {};
        const publicHolidays = businessData?.publicHolidays || [];

        // ‚ö° Get attendance events for this employee and month (IMPROVED: Check Both Structures)
        const eventsByDate = new Map();
        console.log('Fetching attendance events for employee:', employeeId, 'month:', month);
        
        // STRATEGY 1: Query nested structure (current format)
        console.log('Checking nested structure first...');
        for (let day = 1; day <= daysInMonth; day++) {
          const dateStr = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          
          try {
            // Query nested structure: attendance_events/{date}/{employeeId}/*
            const dayEventsRef = collection(db, "businesses", businessId, "attendance_events", dateStr, employeeId);
            const dayEventsSnap = await getDocs(dayEventsRef);
            
            dayEventsSnap.forEach(doc => {
              const event = doc.data();
              console.log('Found nested event:', event);
              
              // Skip test events
              if (event.testMode) {
                console.log('Skipping test event:', event);
                return;
              }
              
              if (event.timestamp) {
                const eventDate = new Date(event.timestamp);
                
                // ‚ú® PUNCH MODULE INTEGRATION: Exclude unresolved pending punches from timecard
                // Pending punches (misspunches) should not appear in timecards unless manually resolved
                if (event.status === 'pending' && !event.resolvedManually) {
                  console.log('Excluding unresolved pending punch from timecard (nested):', event);
                  return; // Skip this event
                }
                
                // Determine event type
                let eventType = null;
                if (event.type) eventType = event.type;
                else if (event.attendanceStatus) {
                  eventType = event.attendanceStatus === 'in' ? 'clock-in' : 'clock-out';
                }
                
                if (eventType) {
                  if (!eventsByDate.has(dateStr)) {
                    eventsByDate.set(dateStr, []);
                  }
                  
                  // Check for duplicates in nested events too
                  const existing = eventsByDate.get(dateStr);
                  const isDuplicate = existing.some(e => {
                    const timeDiff = Math.abs(new Date(e.timestamp).getTime() - new Date(event.timestamp).getTime());
                    return timeDiff < 30000 && e.type === eventType; // Within 30 seconds and same type
                  });
                  
                  if (!isDuplicate) {
                    existing.push({
                      type: eventType,
                      timestamp: event.timestamp,
                      time: eventDate,
                      source: event.source || 'nested',
                      eventId: doc.id
                    });
                    
                    console.log('Added nested event:', { date: dateStr, type: eventType, time: eventDate });
                  } else {
                    console.log('Skipped duplicate nested event:', { date: dateStr, type: eventType, time: eventDate });
                  }
                }
              }
            });
          } catch (dayError) {
            // Day might not exist - that's ok
            console.log('No nested events for date:', dateStr);
          }
        }
        
        // STRATEGY 2: Fallback to flat structure (legacy format)
        console.log('Checking flat structure as fallback...');
        try {
          const flatAttendanceRef = collection(db, "businesses", businessId, "attendance_events");
          const flatAttendanceSnap = await getDocs(flatAttendanceRef);
          
          const startDate = `${year}-${String(monthNum).padStart(2, '0')}-01`;
          const endDate = `${year}-${String(monthNum).padStart(2, '0')}-${daysInMonth}`;
          
          flatAttendanceSnap.forEach(doc => {
            const event = doc.data();
            if (event.employeeId === employeeId && event.timestamp) {
              const eventDate = new Date(event.timestamp);
              const dateStr = eventDate.toISOString().split('T')[0];
              
              // Only include events in this month and skip test events
              if (dateStr >= startDate && dateStr <= endDate && !event.testMode) {
                
                // ‚ú® PUNCH MODULE INTEGRATION: Exclude unresolved pending punches from timecard
                // Pending punches (misspunches) should not appear in timecards unless manually resolved
                if (event.status === 'pending' && !event.resolvedManually) {
                  console.log('Excluding unresolved pending punch from timecard:', event);
                  return; // Skip this event
                }
                
                let eventType = null;
                if (event.type) eventType = event.type;
                else if (event.eventType) eventType = event.eventType;
                else if (event.action) eventType = event.action;
                else if (event.attendanceStatus) {
                  eventType = event.attendanceStatus === 'in' ? 'clock-in' : 'clock-out';
                }
                
                if (eventType) {
                  // Only add if we don't already have events for this date (nested takes priority)
                  if (!eventsByDate.has(dateStr)) {
                    eventsByDate.set(dateStr, []);
                  }
                  
                  // Enhanced duplicate detection (check timestamp within 30 seconds)
                  const existing = eventsByDate.get(dateStr);
                  const isDuplicate = existing.some(e => {
                    const timeDiff = Math.abs(new Date(e.timestamp).getTime() - new Date(event.timestamp).getTime());
                    return timeDiff < 30000 && e.type === eventType; // Within 30 seconds and same type
                  });
                  
                  if (!isDuplicate) {
                    existing.push({
                      type: eventType,
                      timestamp: event.timestamp,
                      time: eventDate,
                      source: event.source || 'flat',
                      eventId: doc.id
                    });
                    
                    console.log('Added flat event:', { date: dateStr, type: eventType, time: eventDate });
                  } else {
                    console.log('Skipped duplicate event:', { date: dateStr, type: eventType, time: eventDate });
                  }
                }
              }
            }
          });
        } catch (flatError) {
          console.log('No flat events found:', flatError);
        }
        
        console.log('Total events by date:', eventsByDate.size, 'days with events');
        console.log('Events by date:', eventsByDate);

        // Build daily records array for all days in month
        for (let day = 1; day <= daysInMonth; day++) {
          const date = new Date(year, monthNum - 1, day, 12, 0, 0);
          const dateStr = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
          const fullDayName = date.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
          
          // Check if this day is configured as a working day
          const daySchedule = schedule[fullDayName];
          const isWorkingDay = daySchedule?.enabled || false;
          const isPublicHoliday = publicHolidays.includes(dateStr);

          const events = eventsByDate.get(dateStr) || [];
          
          if (events.length > 0) {
            // Sort events by time for chronological processing
            events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // FIXED: Chronological event pairing for accurate work time calculation
            console.log('=== DEBUGGING TIME CALCULATION ===');
            console.log('Processing events for', dateStr);
            console.log('Raw events:', events);
            
            // Step 1: Combine and sort ALL events chronologically
            const allEvents = events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            console.log('All events sorted chronologically:', allEvents.map(e => ({
              time: new Date(e.timestamp).toLocaleTimeString(),
              type: e.type,
              timestamp: e.timestamp
            })));
            
            // Step 2: Calculate work periods by pairing sequential in/out events
            let totalMinutes = 0;
            let currentClockIn = null;
            
            console.log('=== CHRONOLOGICAL PAIRING ===');
            
            for (let i = 0; i < allEvents.length; i++) {
              const event = allEvents[i];
              const eventTime = new Date(event.timestamp);
              
              if (event.type === 'clock-in') {
                if (currentClockIn) {
                  console.log('‚ö†Ô∏è Found clock-in while already clocked in - treating as new session');
                }
                currentClockIn = eventTime;
                console.log('üü¢ Clock-in:', eventTime.toLocaleTimeString());
              } 
              else if (event.type === 'clock-out') {
                if (currentClockIn) {
                  // Calculate work period
                  const diffMs = eventTime.getTime() - currentClockIn.getTime();
                  const diffMinutes = Math.max(0, diffMs / (1000 * 60)); // Ensure positive
                  const diffHours = diffMinutes / 60;
                  
                  console.log('üî¥ Clock-out:', eventTime.toLocaleTimeString());
                  console.log('üìä Work period:', currentClockIn.toLocaleTimeString(), '‚Üí', eventTime.toLocaleTimeString());
                  console.log('‚è±Ô∏è Duration:', diffHours.toFixed(2), 'hours');
                  
                  totalMinutes += diffMinutes;
                  currentClockIn = null; // Reset for next period
                } else {
                  console.log('‚ö†Ô∏è Clock-out without matching clock-in - skipping');
                }
              }
            }
            
            // Handle case where last event was clock-in (still working)
            if (currentClockIn) {
              console.log('‚ö†Ô∏è Day ended with clock-in (no clock-out) - not counting incomplete period');
            }
            
            const actualHours = Math.round((totalMinutes / 60) * 100) / 100;
            console.log('=== PAYROLL CALCULATION ===');
            console.log('Raw time worked:', actualHours, 'hours');
            
            // Get business settings
            const businessData = await getDoc(doc(db, "businesses", businessId));
            const breakMinutes = businessData.exists() ? (businessData.data().breakDuration || 60) : 60;
            const businessInfo = businessData.exists() ? businessData.data() : {};
            
            // Calculate scheduled work hours (shift duration minus lunch)
            let scheduledWorkHours = 8; // Default 8 hours
            let scheduledStartTime = '08:30';
            let scheduledEndTime = '17:30';
            
            // Check business-level work times first (from edit business page)
            if (businessInfo.workStartTime && businessInfo.workEndTime) {
              scheduledStartTime = businessInfo.workStartTime;
              scheduledEndTime = businessInfo.workEndTime;
              const [startH, startM] = scheduledStartTime.split(':').map(Number);
              const [endH, endM] = scheduledEndTime.split(':').map(Number);
              const shiftDuration = (endH + endM/60) - (startH + startM/60);
              scheduledWorkHours = Math.max(0, shiftDuration - (breakMinutes / 60));
            }
            // Fallback to day-specific schedule
            else if (daySchedule && daySchedule.startTime && daySchedule.endTime) {
              scheduledStartTime = daySchedule.startTime;
              scheduledEndTime = daySchedule.endTime;
              const [startH, startM] = scheduledStartTime.split(':').map(Number);
              const [endH, endM] = scheduledEndTime.split(':').map(Number);
              const shiftDuration = (endH + endM/60) - (startH + startM/60);
              scheduledWorkHours = Math.max(0, shiftDuration - (breakMinutes / 60));
            }
            
            console.log('üìÖ Scheduled shift:', scheduledStartTime, '-', scheduledEndTime);
            console.log('üçΩÔ∏è Lunch break:', breakMinutes, 'minutes');
            console.log('üíº Scheduled work hours:', scheduledWorkHours);
            
            // Get actual first clock-in and last clock-out for the day
            const firstClockIn = allEvents.find(e => e.type === 'clock-in');
            const lastClockOut = allEvents.filter(e => e.type === 'clock-out').pop();
            
            let payableHours = 0;
            
            if (firstClockIn && lastClockOut) {
              const actualStart = new Date(firstClockIn.timestamp);
              const actualEnd = new Date(lastClockOut.timestamp);
              
              // Create scheduled start/end times for comparison
              const [schedStartH, schedStartM] = scheduledStartTime.split(':').map(Number);
              const [schedEndH, schedEndM] = scheduledEndTime.split(':').map(Number);
              
              const schedStart = new Date(actualStart);
              schedStart.setHours(schedStartH, schedStartM, 0, 0);
              
              const schedEnd = new Date(actualStart);
              schedEnd.setHours(schedEndH, schedEndM, 0, 0);
              
              // Calculate payable start (later of actual start or scheduled start)
              const payableStart = new Date(Math.max(actualStart.getTime(), schedStart.getTime()));
              
              // Calculate payable end (earlier of actual end or scheduled end)
              const payableEnd = new Date(Math.min(actualEnd.getTime(), schedEnd.getTime()));
              
              // Calculate hours between payable start and end
              const payableDuration = Math.max(0, (payableEnd.getTime() - payableStart.getTime()) / (1000 * 60 * 60));
              
              // Subtract lunch break
              payableHours = Math.max(0, payableDuration - (breakMinutes / 60));
              
              // Cap at scheduled work hours
              payableHours = Math.min(payableHours, scheduledWorkHours);
              
              console.log('‚è∞ Actual: ', actualStart.toLocaleTimeString(), '-', actualEnd.toLocaleTimeString());
              console.log('üìã Payable:', payableStart.toLocaleTimeString(), '-', payableEnd.toLocaleTimeString());
              console.log('üí∞ Payable hours (after lunch & caps):', payableHours);
            } else {
              console.log('‚ö†Ô∏è Incomplete day - no matching clock-in/out pair');
            }
            
            const finalHours = Math.round(payableHours * 100) / 100;
            const overtime = Math.max(0, finalHours - scheduledWorkHours);

            dailyRecords.push({
              date: dateStr,
              day: day,
              dayName: dayName,
              fullDayName: fullDayName,
              isWorkingDay: isWorkingDay,
              isPublicHoliday: isPublicHoliday,
              daySchedule: daySchedule,
              clockIns: events.filter(e => e.type === 'clock-in').map(e => e.time),
              clockOuts: events.filter(e => e.type === 'clock-out').map(e => e.time),
              totalHours: finalHours,
              overtime: overtime,
              hasData: true
            });
          } else {
            // No data for this day - determine status
            dailyRecords.push({
              date: dateStr,
              day: day,
              dayName: dayName,
              fullDayName: fullDayName,
              isWorkingDay: isWorkingDay,
              isPublicHoliday: isPublicHoliday,
              daySchedule: daySchedule,
              clockIns: [],
              clockOuts: [],
              totalHours: 0,
              overtime: 0,
              hasData: false
            });
          }
        }

        // ‚ú® Count excluded pending punches for reporting
        let excludedPunchesCount = 0;
        
        // Check flat structure for excluded punches
        try {
          const flatAttendanceRef = collection(db, "businesses", businessId, "attendanceEvents");
          const flatAttendanceSnap = await getDocs(flatAttendanceRef);
          
          flatAttendanceSnap.forEach(doc => {
            const event = doc.data();
            if (event.employeeId === employeeId && event.timestamp) {
              const eventDate = new Date(event.timestamp);
              const dateStr = eventDate.toISOString().split('T')[0];
              
              // Count excluded pending punches in this month
              if (dateStr >= startDate && dateStr <= endDate && !event.testMode) {
                if (event.status === 'pending' && !event.resolvedManually) {
                  excludedPunchesCount++;
                }
              }
            }
          });
        } catch (error) {
          console.log('Error counting excluded punches:', error);
        }

        // Calculate totals
        const totalHours = dailyRecords.reduce((sum, record) => sum + record.totalHours, 0);
        const totalOvertime = dailyRecords.reduce((sum, record) => sum + record.overtime, 0);
        const daysWorked = dailyRecords.filter(r => r.hasData).length;

        // Render timecard with detailed punch records
        display.innerHTML = `
          <div class="timecard-header">
            <h3>${employee.employeeName} - ${monthName}</h3>
            <p>Slot ${employee.slot || employeeId} ‚Ä¢ Badge ${employee.badgeNumber || 'N/A'}</p>
            ${excludedPunchesCount > 0 ? 
              `<div class="timecard-notice" style="background: #fff3cd; border: 1px solid #ffc107; padding: 0.75rem; border-radius: 6px; margin: 0.5rem 0; color: #856404;">
                <strong>‚ö†Ô∏è Notice:</strong> ${excludedPunchesCount} misspunch${excludedPunchesCount > 1 ? 'es' : ''} excluded from timecard. 
                <a href="#" onclick="switchModule('punches')" style="color: #856404; text-decoration: underline;">Manage in Punches module</a>
              </div>` : ''
            }
          </div>

          <div class="timecard-table-wrapper">
            <table class="timecard-table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Day</th>
                  <th>Time</th>
                  <th>Action</th>
                  <th>Status</th>
                  <th>Shift</th>
                  <th>Daily Hours</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                ${dailyRecords.map(record => {
                  const dateStr = `${year}-${String(monthNum).padStart(2, '0')}-${String(record.day).padStart(2, '0')}`;
                  const rowClass = !record.isWorkingDay || record.isPublicHoliday ? 'weekend' : '';
                  
                  // Determine shift based on schedule
                  let shift = '-';
                  if (record.isPublicHoliday) {
                    shift = 'PUBLIC HOLIDAY';
                  } else if (record.isWorkingDay && record.daySchedule) {
                    shift = `${record.daySchedule.startTime || '08:00'}-${record.daySchedule.endTime || '17:00'}`;
                  } else if (!record.isWorkingDay) {
                    shift = 'DAY OFF';
                  }
                  
                  // If no punches for this day, show single row
                  if (!record.hasData) {
                    let status = 'NO DATA';
                    if (record.isPublicHoliday) {
                      status = 'PUBLIC HOLIDAY';
                    } else if (!record.isWorkingDay) {
                      status = 'DAY OFF';
                    } else if (record.isWorkingDay) {
                      status = 'ABSENT';
                    }
                    
                    return `
                      <tr class="${rowClass}">
                        <td class="day-date">${dateStr}</td>
                        <td class="day-name">${record.dayName}</td>
                        <td>-</td>
                        <td>-</td>
                        <td class="no-data">${status}</td>
                        <td>${shift}</td>
                        <td>0.00</td>
                        <td>-</td>
                      </tr>
                    `;
                  }
                  
                  // Get all events for this day sorted by time
                  const events = eventsByDate.get(dateStr) || [];
                  const sortedEvents = events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                  
                  // Process events to determine status and pairing
                  const punchRows = [];
                  let currentClockIn = null;
                  let dailyPeriods = [];
                  
                  sortedEvents.forEach((event, index) => {
                    const eventTime = new Date(event.timestamp).toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                    let status = '';
                    let notes = '';
                    
                    if (event.type === 'clock-in') {
                      if (currentClockIn) {
                        // Previous clock-in was never paired - mark it as pending
                        status = 'PENDING';
                        notes = 'No matching clock-out';
                      } else {
                        status = 'CLOCKED IN';
                        notes = 'Started work';
                      }
                      currentClockIn = event;
                    } else if (event.type === 'clock-out') {
                      if (currentClockIn) {
                        // Calculate work period
                        const startTime = new Date(currentClockIn.timestamp);
                        const endTime = new Date(event.timestamp);
                        const diffMinutes = (endTime - startTime) / (1000 * 60);
                        const periodHours = (diffMinutes / 60).toFixed(2);
                        
                        dailyPeriods.push({ start: startTime, end: endTime, hours: parseFloat(periodHours) });
                        
                        status = 'CLOCKED OUT';
                        notes = `Work period: ${periodHours}h`;
                        currentClockIn = null;
                      } else {
                        status = 'MISPUNCH';
                        notes = 'Clock-out without matching clock-in';
                        // Add action buttons for mispunch management
                        const mispunchId = `mispunch_${event.timestamp}_${event.employeeId}`;
                        notes += ` <span class="mispunch-actions">
                          <button onclick="manageMispunch('${mispunchId}', '${event.id}', 'clock_out_no_in', '${event.employeeName}')" 
                                  class="btn-mispunch" title="Manage this mispunch">
                            ‚ö†Ô∏è Fix
                          </button>
                        </span>`;
                      }
                    }
                    
                    // Determine if this is the first row for the day
                    const isFirstRow = index === 0;
                    const showDayInfo = isFirstRow;
                    
                    punchRows.push(`
                      <tr class="${rowClass}">
                        <td class="${showDayInfo ? 'day-date' : ''}">${showDayInfo ? dateStr : ''}</td>
                        <td class="${showDayInfo ? 'day-name' : ''}">${showDayInfo ? record.dayName : ''}</td>
                        <td class="time-${event.type.includes('in') ? 'in' : 'out'}">${eventTime}</td>
                        <td><strong>${event.type.toUpperCase().replace('-', ' ')}</strong></td>
                        <td class="${status.toLowerCase().replace(' ', '-')}">${status}</td>
                        <td>${showDayInfo ? shift : ''}</td>
                        <td>${showDayInfo ? formatHours(record.totalHours) : ''}</td>
                        <td style="font-size: 0.85rem; color: #666;">${notes}</td>
                      </tr>
                    `);
                  });
                  
                  // If the last event was a clock-in (still pending), mark it
                  if (currentClockIn && punchRows.length > 0) {
                    // Check if it's been pending for more than 24 hours (potential mispunch)
                    const pendingHours = (new Date() - new Date(currentClockIn.timestamp)) / (1000 * 60 * 60);
                    const isPotentialMispunch = pendingHours > 24;
                    
                    // Update the last clock-in row to show pending status
                    const lastRowIndex = punchRows.length - 1;
                    
                    if (isPotentialMispunch) {
                      // Treat as mispunch if pending too long
                      const mispunchId = `mispunch_${currentClockIn.timestamp}_${currentClockIn.employeeId}`;
                      punchRows[lastRowIndex] = punchRows[lastRowIndex].replace(
                        'CLOCKED IN', 
                        'MISPUNCH'
                      ).replace(
                        'Started work', 
                        `Still clocked in ${Math.round(pendingHours)}h ago - missing clock-out <span class="mispunch-actions">
                          <button onclick="manageMispunch('${mispunchId}', '${currentClockIn.id}', 'clock_in_no_out', '${currentClockIn.employeeName}')" 
                                  class="btn-mispunch" title="Manage this mispunch">
                            ‚ö†Ô∏è Fix
                          </button>
                        </span>`
                      ).replace('clocked-in', 'mispunch');
                    } else {
                      // Normal pending status
                      punchRows[lastRowIndex] = punchRows[lastRowIndex].replace(
                        'CLOCKED IN', 
                        'PENDING'
                      ).replace(
                        'Started work', 
                        `Still clocked in - no clock-out (${Math.round(pendingHours)}h ago)`
                      );
                    }
                  }
                  
                  return punchRows.join('');
                }).join('')}
              </tbody>
            </table>
          </div>

          <div class="timecard-summary">
            <div class="summary-grid">
              <div class="summary-section">
                <div class="summary-item">
                  <span class="summary-label">Normal</span>
                  <span class="summary-value">${formatHours(totalHours - totalOvertime)}</span>
                </div>
                <div class="summary-item">
                  <span class="summary-label">OT 1.25</span>
                  <span class="summary-value">${formatHours(totalOvertime)}</span>
                </div>
              </div>
              
              <div class="summary-section">
                <div class="summary-item">
                  <span class="summary-label">Breaks</span>
                  <span class="summary-value">00:00</span>
                </div>
                <div class="summary-item">
                  <span class="summary-label">Lunch</span>
                  <span class="summary-value">${(daysWorked * 1).toFixed(2)}:00</span>
                </div>
                <div class="summary-item">
                  <span class="summary-label">Tea</span>
                  <span class="summary-value">00:00</span>
                </div>
                <div class="summary-item">
                  <span class="summary-label">Shifts Worked</span>
                  <span class="summary-value">${daysWorked}</span>
                </div>
              </div>
            </div>
          </div>
        `;

      } catch (error) {
        console.error("Error loading timecard:", error);
        display.innerHTML = '<div style="text-align: center; padding: 3rem; color: #e53e3e;">Error loading timecard: ' + error.message + '</div>';
      }
    }

    function printTimecard() {
      // Update print date before printing
      const printDateEl = document.getElementById('printDate');
      if (printDateEl) {
        const now = new Date();
        printDateEl.textContent = now.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      
      window.print();
    }

    // Make timecard functions globally available
    // Function to clean up invalid/test events and duplicates
    async function cleanupAttendanceEvents() {
      if (!confirm('This will clean up duplicate and invalid attendance events. Continue?')) {
        return;
      }

      try {
        console.log('üßπ Starting attendance cleanup...');
        
        let totalDeleted = 0;
        let duplicatesDeleted = 0;
        let invalidDeleted = 0;
        
        // Get all dates with attendance events
        const attendanceRef = collection(db, "businesses", businessId, "attendance_events");
        const datesSnap = await getDocs(attendanceRef);
        
        for (const dateDoc of datesSnap.docs) {
          const dateStr = dateDoc.id;
          console.log(`Processing date: ${dateStr}`);
          
          // Get all employees for this date
          const employeesRef = collection(db, "businesses", businessId, "attendance_events", dateStr);
          const employeesSnap = await getDocs(employeesRef);
          
          for (const empDoc of employeesSnap.docs) {
            const employeeId = empDoc.id;
            console.log(`Processing employee ${employeeId} for ${dateStr}`);
            
            // Get all events for this employee on this date
            const eventsRef = collection(db, "businesses", businessId, "attendance_events", dateStr, employeeId);
            const eventsSnap = await getDocs(eventsRef);
            
            const events = [];
            eventsSnap.forEach(doc => {
              events.push({ id: doc.id, ...doc.data(), docRef: doc.ref });
            });
            
            console.log(`Found ${events.length} events for employee ${employeeId} on ${dateStr}`);
            
            // Sort events by timestamp
            events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Track events to delete
            const toDelete = [];
            
            // STEP 1: Remove invalid events
            events.forEach(event => {
              const shouldDelete = (
                event.testMode === true ||
                !event.employeeId ||
                !event.timestamp ||
                (!event.type && !event.eventType && !event.action && !event.attendanceStatus) ||
                event.source === 'demo' || // Remove demo events
                event.timestamp === 'demo' // Remove demo timestamps
              );
              
              if (shouldDelete) {
                toDelete.push({ event, reason: 'Invalid event' });
                invalidDeleted++;
              }
            });
            
            // STEP 2: Remove duplicate events (events within 30 seconds of each other with same type)
            const duplicateMap = new Map();
            events.forEach((event, index) => {
              if (toDelete.some(d => d.event.id === event.id)) return; // Skip if already marked for deletion
              
              const eventTime = new Date(event.timestamp).getTime();
              const eventType = event.type || event.eventType || event.action || 
                              (event.attendanceStatus === 'in' ? 'clock-in' : 'clock-out');
              
              const key = `${eventType}_${Math.floor(eventTime / 30000)}`; // 30-second buckets
              
              if (duplicateMap.has(key)) {
                // This is a potential duplicate
                const existing = duplicateMap.get(key);
                const timeDiff = Math.abs(eventTime - new Date(existing.timestamp).getTime());
                
                if (timeDiff < 30000) { // Within 30 seconds
                  toDelete.push({ event, reason: 'Duplicate event (within 30s)' });
                  duplicatesDeleted++;
                  console.log(`Marking duplicate: ${event.timestamp} vs ${existing.timestamp}`);
                }
              } else {
                duplicateMap.set(key, event);
              }
            });
            
            // STEP 3: Remove sequential same-type events (CLOCK OUT -> CLOCK OUT)
            const validEvents = events.filter(event => !toDelete.some(d => d.event.id === event.id));
            validEvents.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            for (let i = 1; i < validEvents.length; i++) {
              const prevEvent = validEvents[i - 1];
              const currEvent = validEvents[i];
              
              const prevType = prevEvent.type || prevEvent.eventType || prevEvent.action ||
                             (prevEvent.attendanceStatus === 'in' ? 'clock-in' : 'clock-out');
              const currType = currEvent.type || currEvent.eventType || currEvent.action ||
                             (currEvent.attendanceStatus === 'in' ? 'clock-in' : 'clock-out');
              
              if (prevType === currType && !toDelete.some(d => d.event.id === currEvent.id)) {
                toDelete.push({ event: currEvent, reason: `Sequential ${currType} events` });
                duplicatesDeleted++;
                console.log(`Marking sequential duplicate: ${currType} at ${currEvent.timestamp}`);
              }
            }
            
            // Delete marked events
            for (const deletion of toDelete) {
              await deleteDoc(deletion.event.docRef);
              totalDeleted++;
              console.log(`Deleted: ${deletion.reason} - ${deletion.event.type} at ${deletion.event.timestamp}`);
            }
          }
        }
        
        console.log(`‚úÖ Cleanup complete: ${totalDeleted} events deleted (${invalidDeleted} invalid, ${duplicatesDeleted} duplicates)`);
        
        // Show success message
        showNotification(`üßπ Cleanup completed! Deleted ${totalDeleted} duplicate/invalid events.`, 'success');
        
        // Reload the timecard to show clean data
        await loadTimecard();
        alert(`‚úÖ Cleanup complete!\n\n` +
              `Total deleted: ${totalDeleted} events\n` +
              `Invalid events: ${invalidDeleted}\n` +
              `Duplicates: ${duplicatesDeleted}\n\n` +
              `Refresh timecard to see corrected data.`);
              
      } catch (error) {
        console.error('Error cleaning up events:', error);
        alert('Error cleaning up events: ' + error.message);
      }
    }

    // Check for duplicate issues without deleting
    async function checkForDuplicates() {
      try {
        console.log('üîç Checking for duplicate issues...');
        
        let totalIssues = 0;
        let duplicateIssues = 0;
        let mispunchIssues = 0;
        
        const attendanceRef = collection(db, "businesses", businessId, "attendance_events");
        const datesSnap = await getDocs(attendanceRef);
        
        const issueReport = [];
        
        for (const dateDoc of datesSnap.docs) {
          const dateStr = dateDoc.id;
          
          const employeesRef = collection(db, "businesses", businessId, "attendance_events", dateStr);
          const employeesSnap = await getDocs(employeesRef);
          
          for (const empDoc of employeesSnap.docs) {
            const employeeId = empDoc.id;
            
            const eventsRef = collection(db, "businesses", businessId, "attendance_events", dateStr, employeeId);
            const eventsSnap = await getDocs(eventsRef);
            
            const events = [];
            eventsSnap.forEach(doc => {
              events.push({ id: doc.id, ...doc.data() });
            });
            
            if (events.length > 0) {
              events.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
              
              // Check for duplicate times (within 30 seconds)
              for (let i = 0; i < events.length - 1; i++) {
                for (let j = i + 1; j < events.length; j++) {
                  const event1 = events[i];
                  const event2 = events[j];
                  const timeDiff = Math.abs(new Date(event1.timestamp) - new Date(event2.timestamp));
                  
                  if (timeDiff < 30000) {
                    issueReport.push({
                      type: 'duplicate',
                      date: dateStr,
                      employee: employeeId,
                      issue: `Duplicate events within 30s: ${new Date(event1.timestamp).toLocaleTimeString()} and ${new Date(event2.timestamp).toLocaleTimeString()}`
                    });
                    duplicateIssues++;
                  }
                }
              }
              
              // Check for mispunch patterns (sequential same-type events)
              for (let i = 0; i < events.length - 1; i++) {
                const current = events[i];
                const next = events[i + 1];
                const currentType = current.type || current.eventType || (current.attendanceStatus === 'in' ? 'clock-in' : 'clock-out');
                const nextType = next.type || next.eventType || (next.attendanceStatus === 'in' ? 'clock-in' : 'clock-out');
                
                if (currentType === nextType) {
                  issueReport.push({
                    type: 'mispunch',
                    date: dateStr,
                    employee: employeeId,
                    issue: `Sequential ${currentType} events: ${new Date(current.timestamp).toLocaleTimeString()} ‚Üí ${new Date(next.timestamp).toLocaleTimeString()}`
                  });
                  mispunchIssues++;
                }
              }
            }
          }
        }
        
        // Show report
        totalIssues = duplicateIssues + mispunchIssues;
        
        if (totalIssues === 0) {
          alert('üéâ No duplicate or mispunch issues found!');
        } else {
          let reportText = `üìä Found ${totalIssues} issues:\n`;
          reportText += `‚Ä¢ ${duplicateIssues} duplicate events\n`;
          reportText += `‚Ä¢ ${mispunchIssues} mispunch patterns\n\n`;
          
          if (issueReport.length > 0) {
            reportText += 'Sample issues:\n';
            issueReport.slice(0, 5).forEach(issue => {
              reportText += `- ${issue.date} ${issue.employee}: ${issue.issue}\n`;
            });
            
            if (issueReport.length > 5) {
              reportText += `... and ${issueReport.length - 5} more`;
            }
          }
          
          reportText += '\n\nUse "Clean Data" button to fix these issues.';
          console.log('Issue report:', issueReport);
          alert(reportText);
        }
        
      } catch (error) {
        console.error('Check failed:', error);
        alert('Check failed: ' + error.message);
      }
    }

    window.loadTimecard = loadTimecard;
    window.printTimecard = printTimecard;
    window.cleanupAttendanceEvents = cleanupAttendanceEvents;
    window.checkForDuplicates = checkForDuplicates;
    window.initTimecard = initTimecard;

    // ============================================
    // PUNCHES MODULE FUNCTIONS
    // ============================================
    
    let currentPunchForResolution = null;
    
    async function initPunches() {
      try {
        console.log('Initializing punches module...');
        
        // Check if required elements exist
        const dateFilter = document.getElementById('punchDateFilter');
        const employeeFilter = document.getElementById('punchEmployeeFilter');
        
        if (!dateFilter || !employeeFilter) {
          console.error('Required punch elements not found');
          return;
        }
        
        // Set default date to today
        dateFilter.value = new Date().toISOString().split('T')[0];
        
        // Load employees for filter
        await loadPunchEmployees();
        
        // Load initial punches
        await loadPunches();
        
        console.log('Punches module initialized successfully');
        
      } catch (error) {
        console.error('Error initializing punches:', error);
        // Don't show alert that might break other modules
        console.log('Punches module initialization failed, but continuing...');
      }
    }
    
    async function loadPunchEmployees() {
      try {
        // Load from staff collection (where employees are actually stored)
        const staffRef = collection(db, "businesses", businessId, "staff");
        const staffSnap = await getDocs(staffRef);
        
        const employeeSelect = document.getElementById('punchEmployeeFilter');
        employeeSelect.innerHTML = '<option value="">All Employees</option>';
        
        staffSnap.forEach(doc => {
          const emp = doc.data();
          if (emp.active) {
            const option = document.createElement('option');
            option.value = doc.id; // Use slot number as value
            option.textContent = `${emp.employeeName} (Slot ${doc.id})`;
            employeeSelect.appendChild(option);
          }
        });
        
        console.log(`Loaded ${staffSnap.size} employees for punch filter`);
        
      } catch (error) {
        console.error('Error loading employees:', error);
      }
    }
    
    async function loadPunches() {
      try {
        const dateFilter = document.getElementById('punchDateFilter').value;
        const employeeFilter = document.getElementById('punchEmployeeFilter').value;
        const statusFilter = document.getElementById('punchStatusFilter').value;
        
        if (!dateFilter) {
          alert('Please select a date');
          return;
        }
        
        console.log('Loading punches for date:', dateFilter, 'employee:', employeeFilter, 'status:', statusFilter);
        console.log('Business ID:', businessId);
        
        const tableBody = document.getElementById('punchesTableBody');
        tableBody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem;">Loading punches...</td></tr>';
        
        let punches = [];
        
        console.log('=== USING EXACT TIMECARD LOGIC ===');
        console.log('Date filter:', dateFilter);
        console.log('Business ID:', businessId);
        
        try {
          // COPY EXACT LOGIC FROM WORKING TIMECARD
          const eventsByEmployee = new Map();
          console.log('Fetching attendance events for date:', dateFilter);
          
          // STRATEGY 1: Query nested structure (current format) - SAME AS TIMECARD
          console.log('Checking nested structure first...');
          
          // Get all employees first
          const staffRef = collection(db, "businesses", businessId, "staff");
          const staffSnap = await getDocs(staffRef);
          
          for (const staffDoc of staffSnap.docs) {
            const employeeId = staffDoc.id;
            const employeeData = staffDoc.data();
            
            try {
              // Query nested structure: attendance_events/{date}/{employeeId}/*
              const dayEventsRef = collection(db, "businesses", businessId, "attendance_events", dateFilter, employeeId);
              const dayEventsSnap = await getDocs(dayEventsRef);
              
              dayEventsSnap.forEach(doc => {
                const event = doc.data();
                console.log('Found nested event:', event);
                
                // Skip test events
                if (event.testMode) {
                  console.log('Skipping test event:', event);
                  return;
                }
                
                if (event.timestamp) {
                  const eventDate = new Date(event.timestamp);
                  
                  // Determine event type
                  let eventType = null;
                  if (event.type) eventType = event.type;
                  else if (event.attendanceStatus) {
                    eventType = event.attendanceStatus === 'in' ? 'clock-in' : 'clock-out';
                  }
                  
                  if (eventType) {
                    // Create punch object
                    const punch = {
                      id: doc.id,
                      employeeId: employeeId,
                      employeeName: employeeData.employeeName || `Employee ${employeeId}`,
                      slotNumber: parseInt(employeeId),
                      timestamp: event.timestamp,
                      time: eventDate.toLocaleTimeString(),
                      type: eventType,
                      attendanceStatus: event.attendanceStatus || (eventType === 'clock-in' ? 'in' : 'out'),
                      deviceId: event.deviceId || 'Unknown',
                      date: dateFilter,
                      notes: event.notes || '',
                      source: 'nested'
                    };
                    
                    console.log('‚úÖ Created punch from nested structure:', punch);
                    punches.push(punch);
                  }
                }
              });
            } catch (dayError) {
              // Employee might not have events this day - that's ok
              console.log(`No nested events for employee ${employeeId} on date ${dateFilter}`);
            }
          }
          
          // STRATEGY 2: Fallback to flat structure (legacy format) - SAME AS TIMECARD
          console.log('Checking flat structure as fallback...');
          try {
            const flatAttendanceRef = collection(db, "businesses", businessId, "attendance_events");
            const flatAttendanceSnap = await getDocs(flatAttendanceRef);
            
            flatAttendanceSnap.forEach(doc => {
              const event = doc.data();
              if (event.timestamp) {
                const eventDate = new Date(event.timestamp);
                const eventDateStr = eventDate.toISOString().split('T')[0];
                
                // Only include events for selected date and skip test events
                if (eventDateStr === dateFilter && !event.testMode) {
                  
                  // Determine event type
                  let eventType = null;
                  if (event.type) eventType = event.type;
                  else if (event.attendanceStatus) {
                    eventType = event.attendanceStatus === 'in' ? 'clock-in' : 'clock-out';
                  }
                  
                  if (eventType) {
                    // Create punch object
                    const punch = {
                      id: doc.id,
                      employeeId: event.employeeId || 'Unknown',
                      employeeName: event.employeeName || `Employee ${event.employeeId}`,
                      slotNumber: parseInt(event.employeeId || event.slotNumber || '0'),
                      timestamp: event.timestamp,
                      time: eventDate.toLocaleTimeString(),
                      type: eventType,
                      attendanceStatus: event.attendanceStatus || (eventType === 'clock-in' ? 'in' : 'out'),
                      deviceId: event.deviceId || 'Unknown',
                      date: dateFilter,
                      notes: event.notes || '',
                      source: 'flat'
                    };
                    
                    console.log('‚úÖ Created punch from flat structure:', punch);
                    punches.push(punch);
                  }
                }
              }
            });
          } catch (flatError) {
            console.log('Error checking flat structure:', flatError);
          }
          
          console.log(`üìä Total punches found: ${punches.length}`);
          
        } catch (error) {
          console.error('Error loading from standardized collection:', error);
          
          // Fallback: try to load employees to verify collection structure
          try {
            const employeesRef = collection(db, "businesses", businessId, "employees");
            const employeesSnap = await getDocs(employeesRef);
            console.log(`Employees collection has ${employeesSnap.size} documents`);
            
            if (employeesSnap.size === 1 && employeesSnap.docs[0].id === '_structure') {
              console.log('Found structure marker - collections are standardized but empty');
            }
          } catch (empError) {
            console.error('Error checking employees collection:', empError);
          }
        }
        
        // Process found punches
        console.log('Total punches found:', punches.length);
        
        if (punches.length > 0) {
          punches.forEach(punch => {
            // Improve device ID extraction
            if (!punch.deviceId || punch.deviceId === '') {
              // Try to extract from migratedFrom field
              if (punch.migratedFrom && punch.migratedFrom.includes('device_')) {
                const deviceMatch = punch.migratedFrom.match(/device_([^_]+)/);
                if (deviceMatch) {
                  punch.deviceId = deviceMatch[1];
                }
              }
              // Try from original data
              else if (punch.originalData && punch.originalData.deviceId) {
                punch.deviceId = punch.originalData.deviceId;
              }
            }
            
            // Improve employee name display
            if (!punch.employeeName && punch.employeeId) {
              punch.employeeName = punch.employeeId;
            }
            
            // Determine punch status and issues
            punch.status = determinePunchStatus(punch);
            punch.issue = determinePunchIssue(punch);
          });
          
          // Filter by employee if selected
          if (employeeFilter && employeeFilter !== 'All Employees') {
            const beforeFilter = punches.length;
            punches = punches.filter(punch => 
              punch.employeeId === employeeFilter || 
              punch.employeeName === employeeFilter
            );
            console.log(`Employee filter: ${beforeFilter} -> ${punches.length} punches`);
          }
          
          // Filter by status if selected
          if (statusFilter && statusFilter !== 'All Statuses') {
            const beforeFilter = punches.length;
            punches = punches.filter(punch => {
              if (statusFilter === 'Mispunches (Pending)') {
                return punch.status === 'pending' || punch.status === 'mispunch';
              }
              return punch.status === statusFilter.toLowerCase();
            });
            console.log(`Status filter: ${beforeFilter} -> ${punches.length} punches`);
          }
          
          // Sort by timestamp
          punches.sort((a, b) => {
            const timeA = a.timestamp ? (a.timestamp.toDate ? a.timestamp.toDate() : new Date(a.timestamp)) : new Date(0);
            const timeB = b.timestamp ? (b.timestamp.toDate ? b.timestamp.toDate() : new Date(b.timestamp)) : new Date(0);
            return timeA - timeB;
          });
        }
        
        // Update summary
        updatePunchesSummary(punches);
        
        // Populate table
        displayPunches(punches);
        
      } catch (error) {
        console.error('Error loading punches:', error);
        document.getElementById('punchesTableBody').innerHTML = 
          '<tr><td colspan="8" style="text-align: center; color: red;">Error loading punches: ' + error.message + '</td></tr>';
      }
    }
    
    function formatPunchTimestamp(timestamp) {
      try {
        if (!timestamp) {
          return 'Invalid Date';
        }
        
        let date;
        
        // Handle Firestore Timestamp
        if (timestamp && timestamp.toDate) {
          date = timestamp.toDate();
        }
        // Handle string timestamp
        else if (typeof timestamp === 'string') {
          date = new Date(timestamp);
        }
        // Handle number timestamp
        else if (typeof timestamp === 'number') {
          date = new Date(timestamp);
        }
        // Handle Date object
        else if (timestamp instanceof Date) {
          date = timestamp;
        }
        // Handle timestamp with seconds and nanoseconds
        else if (timestamp && timestamp.seconds) {
          date = new Date(timestamp.seconds * 1000);
        }
        else {
          return 'Invalid Date';
        }
        
        // Check if date is valid
        if (isNaN(date.getTime())) {
          return 'Invalid Date';
        }
        
        return date.toLocaleTimeString();
        
      } catch (error) {
        console.error('Error formatting timestamp:', error, timestamp);
        return 'Invalid Date';
      }
    }
    
    function determinePunchStatus(punch) {
      // Check if this is a properly migrated punch with valid data
      if (punch.timestamp && punch.employeeId && punch.type && punch.type !== 'unknown') {
        // Check if this looks like a complete, valid punch
        if (punch.type === 'clock_in' || punch.type === 'clock_out' || 
            punch.type === 'in' || punch.type === 'out') {
          return 'matched';
        }
      }
      
      // If missing key information, it's unmatched
      if (!punch.employeeId || !punch.timestamp) {
        return 'unmatched';
      }
      
      // If type is unknown or unclear, it's pending
      if (!punch.type || punch.type === 'unknown') {
        return 'pending';
      }
      
      // Default to matched if we have the essential data
      return 'matched';
    }
    
    function determinePunchIssue(punch) {
      const issues = [];
      
      if (!punch.employeeId || punch.employeeId === '') {
        issues.push('Missing employee ID');
      }
      
      if (!punch.deviceId || punch.deviceId === '' || punch.deviceId === 'Unknown') {
        issues.push('Missing device reference');
      }
      
      if (!punch.type || punch.type === 'unknown') {
        issues.push('Unknown punch type');
      }
      
      if (punch.migratedFrom && punch.migratedFrom.includes('device_')) {
        issues.push('Migrated from device-specific collection');
      }
      
      if (punch.status === 'pending') {
        issues.push('No matching punch');
      }
      
      if (!punch.deviceEventId && !punch.healed) {
        issues.push('Missing device reference');
      }
      
      if (punch.healed) {
        issues.push('Auto-healed event');
      }
      
      // Check for rapid consecutive punches (potential duplicates)
      if (punch.duplicateFlag) {
        issues.push('Potential duplicate');
      }
      
      // Check for punches outside normal hours
      const punchHour = new Date(punch.timestamp).getHours();
      if (punchHour < 6 || punchHour > 23) {
        issues.push('Outside normal hours');
      }
      
      return issues.length > 0 ? issues.join(', ') : 'None';
    }
    
    function updatePunchesSummary(punches) {
      const summary = punches.reduce((acc, punch) => {
        acc.total++;
        acc[punch.status] = (acc[punch.status] || 0) + 1;
        if (punch.issue !== 'None') acc.withIssues++;
        return acc;
      }, { total: 0, matched: 0, pending: 0, unmatched: 0, withIssues: 0 });
      
      document.getElementById('punchesSummary').innerHTML = `
        <div class="punch-stat-card">
          <h4>Total Punches</h4>
          <p>${summary.total}</p>
        </div>
        <div class="punch-stat-card" style="border-left-color: #059669;">
          <h4>Matched</h4>
          <p>${summary.matched}</p>
        </div>
        <div class="punch-stat-card" style="border-left-color: #d97706;">
          <h4>Misspunches</h4>
          <p>${summary.pending}</p>
        </div>
        <div class="punch-stat-card" style="border-left-color: #dc2626;">
          <h4>Unmatched</h4>
          <p>${summary.unmatched}</p>
        </div>
        <div class="punch-stat-card" style="border-left-color: #7c3aed;">
          <h4>With Issues</h4>
          <p>${summary.withIssues}</p>
        </div>
      `;
    }
    
    function displayPunches(punches) {
      const tableBody = document.getElementById('punchesTableBody');
      
      if (punches.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem;">No punches found for selected criteria</td></tr>';
        return;
      }
      
      const rows = punches.map(punch => {
        const resolveButton = (punch.status === 'pending' || punch.issue !== 'None') ? 
          `<button class="punch-action-btn resolve" onclick="openPunchResolution('${punch.id}')">Resolve</button>` : '';
        
        const deleteButton = (punch.status === 'pending') ? 
          `<button class="punch-action-btn delete" onclick="deletePunchDirectly('${punch.id}')">Delete</button>` : '';
        
        return `
          <tr>
            <td>${punch.date}</td>
            <td>${punch.employeeName || punch.employeeId}</td>
            <td>${formatPunchTimestamp(punch.timestamp)}</td>
            <td>${(punch.status || punch.type || 'UNKNOWN').toUpperCase()}</td>
            <td>${punch.deviceId || 'Unknown'}</td>
            <td><span class="punch-status ${punch.status}">${punch.status.toUpperCase()}</span></td>
            <td>${punch.issue}</td>
            <td>
              <div class="punch-actions">
                ${resolveButton}
                ${deleteButton}
              </div>
            </td>
          </tr>
        `;
      });
      
      tableBody.innerHTML = rows.join('');
    }
    
    function openPunchResolution(punchId) {
      currentPunchForResolution = punchId;
      
      document.getElementById('punchDetails').innerHTML = `
        <p><strong>Punch ID:</strong> ${punchId}</p>
        <p>Loading punch details...</p>
      `;
      
      document.getElementById('punchModal').style.display = 'block';
      
      // Load detailed punch information
      loadPunchDetails(punchId);
    }
    
    async function loadPunchDetails(punchId) {
      try {
        const punchDoc = await getDoc(doc(db, "businesses", businessId, "attendanceEvents", punchId));
        
        if (!punchDoc.exists()) {
          document.getElementById('punchDetails').innerHTML = '<p style="color: red;">Punch not found.</p>';
          return;
        }
        
        const punch = punchDoc.data();
        
        document.getElementById('punchDetails').innerHTML = `
          <div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
            <p><strong>Employee:</strong> ${punch.employeeName || punch.employeeId}</p>
            <p><strong>Date:</strong> ${punch.date}</p>
            <p><strong>Time:</strong> ${new Date(punch.timestamp).toLocaleString()}</p>
            <p><strong>Action:</strong> ${(punch.status || punch.type || 'UNKNOWN').toUpperCase()}</p>
            <p><strong>Device:</strong> ${punch.deviceId || 'Unknown'}</p>
            <p><strong>Status:</strong> ${determinePunchStatus(punch).toUpperCase()}</p>
            <p><strong>Issues:</strong> ${determinePunchIssue(punch)}</p>
            ${punch.healed ? '<p><strong>Note:</strong> This event was auto-healed by the system</p>' : ''}
          </div>
        `;
        
      } catch (error) {
        console.error('Error loading punch details:', error);
        document.getElementById('punchDetails').innerHTML = '<p style="color: red;">Error loading punch details: ' + error.message + '</p>';
      }
    }
    
    function closePunchModal() {
      document.getElementById('punchModal').style.display = 'none';
      currentPunchForResolution = null;
    }
    
    async function markPunchValid() {
      if (!currentPunchForResolution) return;
      
      try {
        // Get the current punch data to determine correct status
        const punchDoc = await getDoc(doc(db, "businesses", businessId, "attendanceEvents", currentPunchForResolution));
        if (!punchDoc.exists()) {
          alert('Punch not found.');
          return;
        }
        
        const punchData = punchDoc.data();
        
        // Determine the correct status based on punch type
        let newStatus = 'clocked in'; // default
        if (punchData.type === 'clock-out' || punchData.attendanceStatus === 'out') {
          newStatus = 'clocked out';
        }
        
        // Update the punch to mark it as validated/resolved
        const punchRef = doc(db, "businesses", businessId, "attendanceEvents", currentPunchForResolution);
        await updateDoc(punchRef, {
          status: newStatus,
          resolvedManually: true,
          resolvedAt: serverTimestamp(),
          resolvedBy: auth.currentUser.email,
          // Remove pending status if it existed
          previousStatus: punchData.status
        });
        
        alert('Punch marked as valid and will now appear in timecards.');
        closePunchModal();
        await loadPunches(); // Refresh the list
        
      } catch (error) {
        console.error('Error marking punch as valid:', error);
        alert('Error resolving punch: ' + error.message);
      }
    }
    
    async function deletePunch() {
      if (!currentPunchForResolution) return;
      
      if (!confirm('Are you sure you want to delete this punch? This action cannot be undone.')) {
        return;
      }
      
      try {
        await deleteDoc(doc(db, "businesses", businessId, "attendanceEvents", currentPunchForResolution));
        
        alert('Punch deleted successfully.');
        closePunchModal();
        await loadPunches(); // Refresh the list
        
      } catch (error) {
        console.error('Error deleting punch:', error);
        alert('Error deleting punch: ' + error.message);
      }
    }
    
    async function deletePunchDirectly(punchId) {
      if (!confirm('Are you sure you want to delete this misspunch? This action cannot be undone.')) {
        return;
      }
      
      try {
        await deleteDoc(doc(db, "businesses", businessId, "attendanceEvents", punchId));
        
        alert('Misspunch deleted successfully.');
        await loadPunches(); // Refresh the list
        
      } catch (error) {
        console.error('Error deleting punch:', error);
        alert('Error deleting punch: ' + error.message);
      }
    }
    
    function adjustPunchTime() {
      if (!currentPunchForResolution) return;
      
      const newTime = prompt('Enter new time (HH:MM format):');
      if (!newTime) return;
      
      // Validate time format
      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
      if (!timeRegex.test(newTime)) {
        alert('Invalid time format. Please use HH:MM format (e.g., 09:30).');
        return;
      }
      
      // Update the punch with new time
      updatePunchTime(currentPunchForResolution, newTime);
    }
    
    async function updatePunchTime(punchId, newTime) {
      try {
        const punchDoc = await getDoc(doc(db, "businesses", businessId, "attendanceEvents", punchId));
        if (!punchDoc.exists()) {
          alert('Punch not found.');
          return;
        }
        
        const punch = punchDoc.data();
        const originalDate = new Date(punch.timestamp);
        
        // Create new timestamp with updated time
        const [hours, minutes] = newTime.split(':');
        const newTimestamp = new Date(originalDate);
        newTimestamp.setHours(parseInt(hours), parseInt(minutes), 0, 0);
        
        // Update the punch
        const punchRef = doc(db, "businesses", businessId, "attendanceEvents", punchId);
        await updateDoc(punchRef, {
          timestamp: newTimestamp.toISOString(),
          adjustedManually: true,
          originalTimestamp: punch.timestamp,
          adjustedAt: serverTimestamp(),
          adjustedBy: auth.currentUser.email
        });
        
        alert('Punch time updated successfully.');
        closePunchModal();
        await loadPunches(); // Refresh the list
        
      } catch (error) {
        console.error('Error updating punch time:', error);
        alert('Error updating punch time: ' + error.message);
      }
    }
    
    function convertToBreak() {
      if (!currentPunchForResolution) return;
      
      if (!confirm('Convert this punch to a break entry? This will mark it as break time and exclude it from work hours.')) {
        return;
      }
      
      updatePunchType(currentPunchForResolution, 'break');
    }
    
    async function updatePunchType(punchId, newType) {
      try {
        const punchRef = doc(db, "businesses", businessId, "attendanceEvents", punchId);
        await updateDoc(punchRef, {
          type: newType,
          originalType: 'clock-in', // or whatever it was
          convertedManually: true,
          convertedAt: serverTimestamp(),
          convertedBy: auth.currentUser.email
        });
        
        alert('Punch converted successfully.');
        closePunchModal();
        await loadPunches(); // Refresh the list
        
      } catch (error) {
        console.error('Error converting punch:', error);
        alert('Error converting punch: ' + error.message);
      }
    }

    // Add punch functions to global scope
    window.loadPunches = loadPunches;
    window.openPunchResolution = openPunchResolution;
    window.closePunchModal = closePunchModal;
    window.markPunchValid = markPunchValid;
    window.deletePunch = deletePunch;
    window.deletePunchDirectly = deletePunchDirectly;
    window.adjustPunchTime = adjustPunchTime;
    window.convertToBreak = convertToBreak;
    window.initPunches = initPunches;
    window.openManualPunchModal = openManualPunchModal;
    window.closeManualPunchModal = closeManualPunchModal;
    window.submitManualPunch = submitManualPunch;
    window.manageMispunch = manageMispunch;
    window.closeMispunchModal = closeMispunchModal;
    window.toggleMispunchOptions = toggleMispunchOptions;
    window.applyMispunchResolution = applyMispunchResolution;
    window.updateManualPunchEmployee = updateManualPunchEmployee;

    // Manual punch functions
    async function openManualPunchModal() {
      // Pre-fill with current date and time
      const now = new Date();
      document.getElementById('manualPunchDate').value = now.toISOString().split('T')[0];
      document.getElementById('manualPunchTime').value = now.toTimeString().slice(0, 5);
      
      // Clear fields
      document.getElementById('manualEmployeeSelect').value = '';
      document.getElementById('manualPunchType').value = '';
      document.getElementById('manualDeviceId').value = '';
      document.getElementById('manualNotes').value = '';
      
      // Load employees into dropdown
      await loadEmployeesForManualPunch();
      
      document.getElementById('manualPunchModal').style.display = 'block';
    }

    async function loadEmployeesForManualPunch() {
      try {
        console.log('Loading employees for manual punch...');
        
        // Load staff data (similar to timecard loading)
        const staffRef = collection(db, "businesses", businessId, "staff");
        const staffSnap = await getDocs(staffRef);
        
        // Load status data to filter active employees
        const statusRef = collection(db, "businesses", businessId, "status");
        const statusSnap = await getDocs(statusRef);
        
        // Create status map
        const statusMap = new Map();
        statusSnap.forEach(doc => {
          const status = doc.data();
          if (status.lastClockTime || status.employeeName) {
            statusMap.set(doc.id, status);
          }
        });

        // Populate employee dropdown
        const employeeSelect = document.getElementById('manualEmployeeSelect');
        employeeSelect.innerHTML = '<option value="">-- Select Employee --</option>';
        
        const employees = [];
        staffSnap.forEach(doc => {
          const staff = doc.data();
          const status = statusMap.get(doc.id);
          
          // Include employees who have either staff record or status record
          const employeeName = staff.employeeName || status?.employeeName || doc.id;
          const slot = staff.slot || status?.slot || doc.id;
          
          employees.push({
            id: doc.id,
            name: employeeName,
            slot: slot
          });
        });

        // Also check status collection for employees without staff records
        statusSnap.forEach(doc => {
          const status = doc.data();
          if (!employees.find(emp => emp.id === doc.id) && status.employeeName) {
            employees.push({
              id: doc.id,
              name: status.employeeName,
              slot: status.slot || doc.id
            });
          }
        });

        // Sort by slot
        employees.sort((a, b) => {
          const slotA = typeof a.slot === 'number' ? a.slot : parseInt(a.slot) || 999;
          const slotB = typeof b.slot === 'number' ? b.slot : parseInt(b.slot) || 999;
          return slotA - slotB;
        });

        // Add to dropdown
        employees.forEach(emp => {
          const option = document.createElement('option');
          option.value = emp.id;
          option.textContent = `${emp.name} (Slot ${emp.slot})`;
          option.dataset.employeeName = emp.name;
          option.dataset.employeeSlot = emp.slot;
          employeeSelect.appendChild(option);
        });

        console.log(`Loaded ${employees.length} employees for manual punch`);
        
      } catch (error) {
        console.error('Error loading employees:', error);
        // Fallback: create a simple input field
        const employeeSelect = document.getElementById('manualEmployeeSelect');
        employeeSelect.innerHTML = '<option value="">Error loading employees - type manually</option>';
      }
    }

    function updateManualPunchEmployee() {
      // This function is called when employee is selected
      const select = document.getElementById('manualEmployeeSelect');
      const selectedOption = select.options[select.selectedIndex];
      
      if (selectedOption && selectedOption.value) {
        console.log('Selected employee:', selectedOption.textContent);
      }
    }

    function closeManualPunchModal() {
      document.getElementById('manualPunchModal').style.display = 'none';
    }

    async function submitManualPunch() {
      try {
        const employeeSelect = document.getElementById('manualEmployeeSelect');
        const selectedOption = employeeSelect.options[employeeSelect.selectedIndex];
        
        if (!selectedOption || !selectedOption.value) {
          alert('Please select an employee');
          return;
        }

        const employeeId = selectedOption.value;
        const employeeName = selectedOption.dataset.employeeName;
        const date = document.getElementById('manualPunchDate').value;
        const time = document.getElementById('manualPunchTime').value;
        const type = document.getElementById('manualPunchType').value;
        const deviceId = document.getElementById('manualDeviceId').value.trim() || 'MANUAL';
        const notes = document.getElementById('manualNotes').value.trim();

        // Validation
        if (!date || !time || !type) {
          alert('Please fill in all required fields');
          return;
        }

        // Create timestamp from date and time
        const timestamp = new Date(`${date}T${time}:00`);
        
        console.log('Creating manual punch via webhook:', { employeeId, employeeName, timestamp, type, deviceId });

        // Convert punch type to attendance status for webhook
        const attendanceStatus = type === 'clock_in' ? 'in' : 
                                type === 'clock_out' ? 'out' : 
                                type === 'break_start' ? 'break_out' : 
                                type === 'break_end' ? 'break_in' : 'in';

        // Prepare webhook payload (same format as device events)
        const webhookPayload = {
          deviceId: deviceId,
          verifyNo: employeeId, // Use employeeId as slot number
          employeeName: employeeName,
          attendanceStatus: attendanceStatus,
          timestamp: timestamp.toISOString(),
          businessId: businessId,
          isManual: true,
          manualNotes: notes,
          manualDate: date
        };

        console.log('Sending to webhook:', webhookPayload);

        // Call the webhook API (same as device events)
        const webhookResponse = await fetch('https://attendancewebhook-4q7htrps4q-uc.a.run.app', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(webhookPayload)
        });

        const webhookResult = await webhookResponse.json();
        
        if (!webhookResult.success) {
          throw new Error(webhookResult.error || 'Webhook processing failed');
        }
        
        console.log('Manual punch processed via webhook:', webhookResult);
        
        // Show success message
        alert(`Manual punch added successfully for ${employeeName}!`);
        
        // Close modal
        closeManualPunchModal();
        
        // Refresh punches if the selected date matches
        const currentDateFilter = document.getElementById('punchDateFilter').value;
        if (currentDateFilter === date) {
          loadPunches();
        }

      } catch (error) {
        console.error('Error creating manual punch:', error);
        alert('Error creating manual punch: ' + error.message);
      }
    }

    // Mispunch management function
    async function manageMispunch(mispunchId, punchId, reason, employeeName) {
      const modal = `
        <div class="modal-overlay" onclick="closeMispunchModal(event)">
          <div class="modal-employee" onclick="event.stopPropagation()">
            <h2>‚ö†Ô∏è Manage Mispunch</h2>
            <div style="margin-bottom: 1rem;">
              <strong>Employee:</strong> ${employeeName}<br>
              <strong>Issue:</strong> ${
                reason === 'clock_out_no_in' ? 'Clock-out without matching clock-in' : 
                reason === 'clock_in_no_out' ? 'Clock-in without matching clock-out (pending too long)' : 
                reason
              }
            </div>
            
            <div class="form-group">
              <label>Resolution Action:</label>
              <select id="mispunchAction" onchange="toggleMispunchOptions()">
                <option value="">Choose an action...</option>
                ${reason === 'clock_out_no_in' ? `
                  <option value="add_missing_in">Add Missing Clock-In</option>
                  <option value="delete_punch">Delete This Clock-Out</option>
                  <option value="convert_break">Convert to Break End</option>
                ` : ''}
                ${reason === 'clock_in_no_out' ? `
                  <option value="add_missing_out">Add Missing Clock-Out</option>
                  <option value="delete_punch">Delete This Clock-In</option>
                  <option value="convert_break">Convert to Break Start</option>
                ` : ''}
                <option value="mark_resolved">Mark as Resolved with Note</option>
              </select>
            </div>
            
            <div id="missingClockInOptions" class="form-group" style="display: none;">
              <label>Estimated Clock-In Time:</label>
              <input type="time" id="estimatedClockIn" value="08:00">
              <small style="color: #666;">Add a clock-in time before this clock-out</small>
            </div>
            
            <div id="missingClockOutOptions" class="form-group" style="display: none;">
              <label>Estimated Clock-Out Time:</label>
              <input type="time" id="estimatedClockOut" value="17:00">
              <small style="color: #666;">Add a clock-out time after this clock-in</small>
            </div>
            
            <div class="form-group">
              <label>Resolution Notes:</label>
              <textarea id="mispunchNotes" placeholder="Explain the resolution (e.g., 'Employee forgot to clock in, added 8:00 AM start time')" rows="3"></textarea>
            </div>
            
            <div class="modal-buttons">
              <button type="button" onclick="closeMispunchModal()" class="btn-secondary">Cancel</button>
              <button type="button" onclick="applyMispunchResolution('${punchId}', '${employeeName}')" class="btn-primary">Apply Resolution</button>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modal);
    }

    function toggleMispunchOptions() {
      const action = document.getElementById('mispunchAction').value;
      const clockInOptions = document.getElementById('missingClockInOptions');
      const clockOutOptions = document.getElementById('missingClockOutOptions');
      
      clockInOptions.style.display = action === 'add_missing_in' ? 'block' : 'none';
      clockOutOptions.style.display = action === 'add_missing_out' ? 'block' : 'none';
    }

    async function applyMispunchResolution(punchId, employeeName) {
      const action = document.getElementById('mispunchAction').value;
      const notes = document.getElementById('mispunchNotes').value;

      if (!action) {
        alert('Please select a resolution action');
        return;
      }

      try {
        switch (action) {
          case 'add_missing_in':
            const estimatedTime = document.getElementById('estimatedClockIn').value;
            if (!estimatedTime) {
              alert('Please specify the estimated clock-in time');
              return;
            }
            
            // Create a new clock-in punch before this clock-out
            const today = new Date().toISOString().split('T')[0];
            const clockInTimestamp = new Date(`${today}T${estimatedTime}:00`);
            
            const webhookPayload = {
              deviceId: 'MISPUNCH_CORRECTION',
              verifyNo: punchId.split('_')[0], // Extract employee slot
              employeeName: employeeName,
              attendanceStatus: 'in',
              timestamp: clockInTimestamp.toISOString(),
              businessId: businessId,
              isManual: true,
              manualNotes: `Mispunch correction: Added missing clock-in. ${notes}`,
              isMispunchCorrection: true
            };

            const response = await fetch('https://attendancewebhook-4q7htrps4q-uc.a.run.app', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(webhookPayload)
            });

            if (!response.ok) {
              throw new Error('Failed to add missing clock-in');
            }

            alert(`Missing clock-in added at ${estimatedTime} for ${employeeName}`);
            break;

          case 'add_missing_out':
            const estimatedOutTime = document.getElementById('estimatedClockOut').value;
            if (!estimatedOutTime) {
              alert('Please specify the estimated clock-out time');
              return;
            }
            
            // Create a new clock-out punch after this clock-in
            const todayOut = new Date().toISOString().split('T')[0];
            const clockOutTimestamp = new Date(`${todayOut}T${estimatedOutTime}:00`);
            
            const clockOutPayload = {
              deviceId: 'MISPUNCH_CORRECTION',
              verifyNo: punchId.split('_')[0], // Extract employee slot
              employeeName: employeeName,
              attendanceStatus: 'out',
              timestamp: clockOutTimestamp.toISOString(),
              businessId: businessId,
              isManual: true,
              manualNotes: `Mispunch correction: Added missing clock-out. ${notes}`,
              isMispunchCorrection: true
            };

            const outResponse = await fetch('https://attendancewebhook-4q7htrps4q-uc.a.run.app', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(clockOutPayload)
            });

            if (!outResponse.ok) {
              throw new Error('Failed to add missing clock-out');
            }

            alert(`Missing clock-out added at ${estimatedOutTime} for ${employeeName}`);
            break;

          case 'delete_punch':
            // In a real implementation, you'd delete the punch from Firestore
            alert(`Punch deleted for ${employeeName}. Notes: ${notes}`);
            break;

          case 'mark_resolved':
            // In a real implementation, you'd mark the punch as resolved
            alert(`Mispunch marked as resolved for ${employeeName}. Notes: ${notes}`);
            break;

          case 'convert_break':
            alert(`Punch converted to break start for ${employeeName}. Notes: ${notes}`);
            break;
        }

        closeMispunchModal();
        await loadPunches(); // Refresh the punch list

      } catch (error) {
        console.error('Error resolving mispunch:', error);
        alert('Error resolving mispunch: ' + error.message);
      }
    }

    function closeMispunchModal(event) {
      if (event && event.target.classList.contains('modal-overlay')) {
        document.querySelector('.modal-overlay')?.remove();
      } else if (!event) {
        document.querySelector('.modal-overlay')?.remove();
      }
    }

    // ============================================
    // DEVICE SYNC MODULE FUNCTIONS
    // ============================================

    async function loadDeviceCollections() {
      try {
        const devicesList = document.getElementById('deviceCollectionsList');
        devicesList.innerHTML = '<p>Loading...</p>';
        
        console.log('Loading device collections for business:', businessId);
        
        // Get business devices
        const devicesRef = collection(db, "businesses", businessId, "devices");
        const devicesSnap = await getDocs(devicesRef);
        
        console.log('Found devices:', devicesSnap.size);
        
        if (devicesSnap.empty) {
          devicesList.innerHTML = '<p class="no-data">No devices configured</p>';
          return;
        }

        let collectionsHtml = '<div class="device-collections">';
        
        for (const deviceDoc of devicesSnap.docs) {
          const deviceId = deviceDoc.id;
          const deviceData = deviceDoc.data();
          
          console.log('Checking device:', deviceId);
          
          // Check if device mirror collection exists by checking today's date
          try {
            const today = new Date().toISOString().split('T')[0];
            const mirrorRef = collection(db, "businesses", businessId, `device_${deviceId}_events`);
            
            // Try to get any document from the collection to check if it exists
            let hasData = false;
            let eventCount = 0;
            
            try {
              const todayRef = doc(db, "businesses", businessId, `device_${deviceId}_events`, today);
              const todaySnap = await getDoc(todayRef);
              
              if (todaySnap.exists()) {
                // Check if there are any subcollections (employee events)
                const subcollections = await todayRef.listCollections();
                hasData = subcollections.length > 0;
                
                for (const subcol of subcollections) {
                  const subSnap = await getDocs(subcol);
                  eventCount += subSnap.size;
                }
              }
            } catch (checkError) {
              console.log('No data for today:', checkError.message);
              hasData = false;
            }
            
            const statusClass = hasData ? 'event-matched' : 'event-missing';
            const statusText = hasData ? `Active (${eventCount} events today)` : 'No Data';
            
            collectionsHtml += `
              <div class="device-collection-item">
                <div class="device-info">
                  <strong>${deviceData.name || deviceId}</strong>
                  <span class="device-id">(${deviceId})</span>
                </div>
                <div class="collection-status ${statusClass}">
                  Collection: device_${deviceId}_events - ${statusText}
                </div>
              </div>
            `;
          } catch (error) {
            console.error('Error checking device collection:', error);
            collectionsHtml += `
              <div class="device-collection-item">
                <div class="device-info">
                  <strong>${deviceData.name || deviceId}</strong>
                  <span class="device-id">(${deviceId})</span>
                </div>
                <div class="collection-status event-missing">
                  Collection: device_${deviceId}_events - Error: ${error.message}
                </div>
              </div>
            `;
          }
        }
        
        collectionsHtml += '</div>';
        devicesList.innerHTML = collectionsHtml;
        
        // Populate device selector
        const deviceSelect = document.getElementById('syncDeviceSelect');
        deviceSelect.innerHTML = '<option value="">All Devices</option>';
        
        devicesSnap.forEach(doc => {
          const deviceData = doc.data();
          deviceSelect.innerHTML += `<option value="${doc.id}">${deviceData.name || doc.id}</option>`;
        });
        
      } catch (error) {
        console.error('Error loading device collections:', error);
        document.getElementById('deviceCollectionsList').innerHTML = '<p class="error">Error loading device collections</p>';
      }
    }

    async function triggerManualSync() {
      try {
        const syncBtn = document.querySelector('[onclick="triggerManualSync()"]');
        const originalText = syncBtn.textContent;
        syncBtn.textContent = 'üîÑ Syncing...';
        syncBtn.disabled = true;
        
        // Call the manual sync function
        const response = await fetch(`https://us-central1-aiclock-82608.cloudfunctions.net/manualDeviceSync?businessId=${businessId}`);
        const result = await response.json();
        
        if (result.success) {
          alert(`‚úÖ Sync completed!\n\nResults:\n${result.results.map(r => `- ${r.deviceId}: ${r.status}`).join('\n')}`);
          
          // Update sync status
          document.getElementById('lastSyncTime').textContent = new Date().toLocaleString();
          
          // Refresh collections view
          await loadDeviceCollections();
        } else {
          throw new Error(result.error || 'Sync failed');
        }
        
      } catch (error) {
        console.error('Manual sync error:', error);
        alert('‚ùå Sync failed: ' + error.message);
      } finally {
        const syncBtn = document.querySelector('[onclick="triggerManualSync()"]');
        syncBtn.textContent = 'üîß Manual Sync';
        syncBtn.disabled = false;
      }
    }

    async function viewDeviceEvents() {
      const deviceId = document.getElementById('syncDeviceSelect').value;
      const date = document.getElementById('syncDateSelect').value;
      
      if (!date) {
        alert('Please select a date');
        return;
      }
      
      try {
        const comparisonDiv = document.getElementById('eventsComparisonTable');
        comparisonDiv.innerHTML = '<p>Loading events...</p>';
        
        let eventsHtml = '<table class="comparison-table"><thead><tr><th>Time</th><th>Device</th><th>Employee</th><th>Action</th><th>Source</th><th>Status</th></tr></thead><tbody>';
        
        // Get all devices if none selected
        const devicesToCheck = deviceId ? [deviceId] : [];
        
        if (!deviceId) {
          const devicesRef = collection(db, "businesses", businessId, "devices");
          const devicesSnap = await getDocs(devicesRef);
          devicesSnap.forEach(doc => devicesToCheck.push(doc.id));
        }
        
        let totalEvents = 0;
        
        for (const checkDeviceId of devicesToCheck) {
          try {
            // Get device events for specific date
            const dateDoc = doc(db, "businesses", businessId, `device_${checkDeviceId}_events`, date);
            const dateDocSnap = await getDoc(dateDoc);
            
            if (!dateDocSnap.exists()) {
              console.log(`No events found for device ${checkDeviceId} on ${date}`);
              continue;
            }
            
            // Get employee subcollections
            const empCollections = await dateDoc.listCollections();
            
            for (const empCollection of empCollections) {
              const empEventsSnap = await getDocs(empCollection);
              
              empEventsSnap.forEach(doc => {
                const event = doc.data();
                const eventTime = new Date(event.timestamp).toLocaleTimeString();
                totalEvents++;
                
                eventsHtml += `
                  <tr class="event-matched">
                    <td>${eventTime}</td>
                    <td>${checkDeviceId}</td>
                    <td>${event.employeeName || empCollection.id}</td>
                    <td>${event.attendanceStatus?.toUpperCase() || 'UNKNOWN'}</td>
                    <td>Device Mirror</td>
                    <td>${event.healed ? 'ü©π Healed' : '‚úÖ Synced'}</td>
                  </tr>
                `;
              });
            }
          } catch (deviceError) {
            console.error(`Error loading events for device ${checkDeviceId}:`, deviceError);
            eventsHtml += `
              <tr class="event-missing">
                <td>-</td>
                <td>${checkDeviceId}</td>
                <td>-</td>
                <td>ERROR</td>
                <td>Device Mirror</td>
                <td>‚ùå ${deviceError.message}</td>
              </tr>
            `;
          }
        }
        
        if (totalEvents === 0) {
          eventsHtml += `
            <tr>
              <td colspan="6" style="text-align: center; padding: 2rem;">
                No device events found for ${date}
                ${deviceId ? ` on device ${deviceId}` : ' on any device'}
              </td>
            </tr>
          `;
        }
        
        eventsHtml += '</tbody></table>';
        comparisonDiv.innerHTML = `
          <div class="comparison-summary">
            <h4>üì± Device Events for ${date}</h4>
            <p><strong>Total Events Found:</strong> ${totalEvents}</p>
            <p><strong>Devices Checked:</strong> ${devicesToCheck.join(', ')}</p>
          </div>
          ${eventsHtml}
        `;
        
      } catch (error) {
        console.error('Error viewing device events:', error);
        document.getElementById('eventsComparisonTable').innerHTML = '<p class="error">Error loading device events: ' + error.message + '</p>';
      }
    }

    async function compareEvents() {
      const deviceId = document.getElementById('syncDeviceSelect').value;
      const date = document.getElementById('syncDateSelect').value;
      
      if (!deviceId || !date) {
        alert('Please select both device and date for comparison');
        return;
      }
      
      try {
        const comparisonDiv = document.getElementById('eventsComparisonTable');
        comparisonDiv.innerHTML = '<p>Comparing events...</p>';
        
        // Get processed events for this device and date
        const processedEventsRef = collection(db, "businesses", businessId, "attendanceEvents");
        const processedQuery = query(processedEventsRef, 
          where("date", "==", date),
          where("deviceId", "==", deviceId)
        );
        const processedSnap = await getDocs(processedQuery);
        const processedEvents = [];
        processedSnap.forEach(doc => processedEvents.push({...doc.data(), id: doc.id}));
        
        // Check if device events collection exists for this date
        const dateDoc = doc(db, "businesses", businessId, `device_${deviceId}_events`, date);
        const dateDocSnap = await getDoc(dateDoc);
        
        let comparisonHtml = `
          <div class="comparison-summary">
            <h4>üìä Sync Status for ${deviceId} on ${date}</h4>
            <p><strong>Processed Events:</strong> ${processedEvents.length}</p>
            <p><strong>Device Collection Exists:</strong> ${dateDocSnap.exists() ? 'Yes' : 'No'}</p>
          </div>
          <table class="comparison-table">
            <thead>
              <tr><th>Employee</th><th>Time</th><th>Action</th><th>Device Mirror</th><th>Processing</th><th>Sync Status</th></tr>
            </thead>
            <tbody>
        `;
        
        if (processedEvents.length === 0) {
          comparisonHtml += `
            <tr>
              <td colspan="6" style="text-align: center; padding: 2rem;">
                No processed events found for device ${deviceId} on ${date}
              </td>
            </tr>
          `;
        } else {
          for (const processedEvent of processedEvents) {
            const hasMirrorEvent = processedEvent.deviceEventId || processedEvent.healed;
            const syncStatus = hasMirrorEvent ? 'Synced' : 'Missing Mirror';
            const statusClass = hasMirrorEvent ? 'event-matched' : 'event-missing';
            
            comparisonHtml += `
              <tr class="${statusClass}">
                <td>${processedEvent.employeeName || processedEvent.employeeId}</td>
                <td>${new Date(processedEvent.timestamp).toLocaleTimeString()}</td>
                <td>${(processedEvent.status || processedEvent.attendanceStatus)?.toUpperCase()}</td>
                <td>${hasMirrorEvent ? '‚úÖ Present' : '‚ùå Missing'}</td>
                <td>‚úÖ Processed</td>
                <td>${syncStatus}${processedEvent.healed ? ' (Auto-healed)' : ''}</td>
              </tr>
            `;
          }
        }
        
        comparisonHtml += '</tbody></table>';
        comparisonDiv.innerHTML = comparisonHtml;
        
      } catch (error) {
        console.error('Error comparing events:', error);
        document.getElementById('eventsComparisonTable').innerHTML = '<p class="error">Error comparing events: ' + error.message + '</p>';
      }
    }

    // Initialize sync view
    async function initDeviceSync() {
      // Set default date to today
      document.getElementById('syncDateSelect').value = new Date().toISOString().split('T')[0];
      
      // Load device collections
      await loadDeviceCollections();
    }

    // Import Test Events Function
    async function importTestEvents() {
      try {
        const dateInput = document.getElementById('syncDateSelect').value;
        if (!dateInput) {
          alert('Please select a date first');
          return;
        }

        // Ask user which employee slot to create test events for
        const employeeId = prompt('Enter employee slot number (1-10) to create test events for:', '1');
        if (!employeeId || isNaN(employeeId) || employeeId < 1 || employeeId > 10) {
          alert('Please enter a valid employee slot number (1-10)');
          return;
        }

        const confirmMsg = `Create test attendance events for Employee ${employeeId} on ${dateInput}?\n\nThis will create:\n- 08:00 Clock In\n- 12:00 Break Out\n- 13:00 Break In\n- 17:30 Clock Out`;
        
        if (!confirm(confirmMsg)) {
          return;
        }

        // Create test events directly in Firebase
        const testEvents = [
          {
            timestamp: `${dateInput}T08:00:00.000Z`,
            attendanceStatus: 'in',
            eventType: 'clock_in'
          },
          {
            timestamp: `${dateInput}T12:00:00.000Z`, 
            attendanceStatus: 'out',
            eventType: 'break_out'
          },
          {
            timestamp: `${dateInput}T13:00:00.000Z`,
            attendanceStatus: 'in', 
            eventType: 'break_in'
          },
          {
            timestamp: `${dateInput}T17:30:00.000Z`,
            attendanceStatus: 'out',
            eventType: 'clock_out'
          }
        ];

        let successCount = 0;

        for (const event of testEvents) {
          // Create attendance event
          const attendanceRef = collection(db, "businesses", businessId, "attendance_events", dateInput, employeeId);
          await addDoc(attendanceRef, {
            employeeId: employeeId,
            employeeName: `Employee ${employeeId}`,
            timestamp: event.timestamp,
            attendanceStatus: event.attendanceStatus,
            eventType: event.eventType,
            processed: true,
            source: 'test_import',
            createdAt: new Date().toISOString()
          });

          // Create device mirror event
          const deviceRef = collection(db, "businesses", businessId, "device_admin_events", dateInput, employeeId);
          await addDoc(deviceRef, {
            employeeId: employeeId,
            employeeName: `Employee ${employeeId}`,
            timestamp: event.timestamp,
            attendanceStatus: event.attendanceStatus,
            eventType: event.eventType,
            deviceId: 'admin',
            source: 'test_import',
            createdAt: new Date().toISOString()
          });

          successCount++;
        }

        alert(`‚úÖ Successfully imported ${successCount} test events for Employee ${employeeId} on ${dateInput}!\n\nYou can now:\n1. View them in the Device Sync "View Events" section\n2. See them in the Punches module\n3. Generate timecards`);

        // Refresh the sync view
        await loadDeviceCollections();
        
      } catch (error) {
        console.error("Error importing test events:", error);
        alert('‚ùå Error importing test events: ' + error.message);
      }
    }

    // Add sync functions to global scope
    window.loadDeviceCollections = loadDeviceCollections;
    window.triggerManualSync = triggerManualSync;
    window.viewDeviceEvents = viewDeviceEvents;
    window.compareEvents = compareEvents;
    window.initDeviceSync = initDeviceSync;
    window.importTestEvents = importTestEvents;

    // ============================================
    // REPORTS MODULE FUNCTIONS
    // ============================================
    
    async function initReports() {
      try {
        // Set default month to current month
        const now = new Date();
        const monthInput = document.getElementById('reportMonth');
        monthInput.value = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        // Load reports for current month
        await loadReports();
      } catch (error) {
        console.error("Error initializing reports:", error);
        alert('Error loading reports: ' + error.message);
      }
    }

    async function loadReports() {
      const month = document.getElementById('reportMonth').value;
      const display = document.getElementById('reportsContent');

      if (!month) {
        display.innerHTML = '<div style="text-align: center; padding: 3rem; color: #999;">Select a month to generate reports</div>';
        return;
      }

      try {
        display.innerHTML = '<div style="text-align: center; padding: 3rem; color: #999;">Generating reports...</div>';

        // Parse month
        const [year, monthNum] = month.split('-');
        const monthDate = new Date(year, monthNum - 1, 1);
        const monthName = monthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        const daysInMonth = new Date(year, monthNum, 0).getDate();

        // Get all active employees
        const staffRef = collection(db, "businesses", businessId, "staff");
        const statusRef = collection(db, "businesses", businessId, "status");
        
        const [staffSnap, statusSnap] = await Promise.all([
          getDocs(staffRef),
          getDocs(statusRef)
        ]);

        // Create status map
        const statusMap = new Map();
        statusSnap.forEach(doc => {
          const status = doc.data();
          if (status.lastClockTime) {
            statusMap.set(doc.id, status);
          }
        });

        // Get active employees
        const employees = [];
        staffSnap.forEach(doc => {
          const staff = doc.data();
          const status = statusMap.get(doc.id);
          
          if (status && status.lastClockTime) {
            employees.push({
              id: doc.id,
              ...staff
            });
          }
        });

        // Sort by slot
        employees.sort((a, b) => (a.slot || 0) - (b.slot || 0));

        if (employees.length === 0) {
          display.innerHTML = '<div class="no-employees">No employees found. Reports will be available after employees clock in.</div>';
          return;
        }

        // Get business schedule settings
        const businessRef = doc(db, "businesses", businessId);
        const businessDoc = await getDoc(businessRef);
        const businessData = businessDoc.data();
        const schedule = businessData?.schedule || {};
        const publicHolidays = businessData?.publicHolidays || [];

        // Calculate attendance and hours for each employee using pre-calculated timesheets
        const employeeReports = [];
        
        for (const employee of employees) {
          let totalHours = 0;
          let totalOvertime = 0;
          let daysWorked = 0;
          let daysAbsent = 0;
          let daysLate = 0;

          // ‚ö° UNIFIED: Load attendance events from single source of truth
          const attendanceRef = collection(db, "businesses", businessId, "attendance_events");
          const q = query(attendanceRef, 
            where("slotNumber", "==", parseInt(employee.id)),
            orderBy("timestamp", "desc")
          );
          const attendanceSnap = await getDocs(q);
          
          // Process attendance events for current month
          const monthPrefix = `${year}-${String(monthNum).padStart(2, '0')}`;
          const dailyEvents = {};
          
          attendanceSnap.forEach(doc => {
            const data = doc.data();
            const eventDate = new Date(data.timestamp).toISOString().split('T')[0];
            
            if (eventDate.startsWith(monthPrefix)) {
              if (!dailyEvents[eventDate]) {
                dailyEvents[eventDate] = [];
              }
              dailyEvents[eventDate].push({
                type: data.attendanceStatus === 'in' || data.attendanceStatus === 'checkIn' ? 'clock-in' : 'clock-out',
                timestamp: data.timestamp
              });
            }
          });
          
          // Calculate hours from daily events
          Object.keys(dailyEvents).forEach(date => {
            const events = dailyEvents[date].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            let dayHours = 0;
            
            for (let i = 0; i < events.length - 1; i += 2) {
              const clockIn = events[i];
              const clockOut = events[i + 1];
              
              if (clockIn.type === 'clock-in' && clockOut && clockOut.type === 'clock-out') {
                const start = new Date(clockIn.timestamp);
                const end = new Date(clockOut.timestamp);
                dayHours += (end - start) / (1000 * 60 * 60); // Convert to hours
              }
            }
            
            totalHours += dayHours;
            
            if (dayHours > 0) {
              daysWorked++;
            }
            
            // Check if late (first clock-in after scheduled start)  
            if (events.length > 0) {
              const firstClockIn = events.find(e => e.type === 'clock-in');
              if (firstClockIn) {
                const clockInTime = new Date(firstClockIn.timestamp);
                const dayOfWeek = new Date(date).toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
                const daySchedule = schedule[dayOfWeek];
                
                if (daySchedule && daySchedule.startTime) {
                  const scheduledStart = new Date(date + 'T' + daySchedule.startTime);
                  if (clockInTime > scheduledStart) {
                    daysLate++;
                  }
                }
              }
            }
          });

          // Calculate expected workdays from schedule
          let expectedWorkdays = 0;
          for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, monthNum - 1, day);
            const dateStr = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
            const daySchedule = schedule[dayOfWeek];
            const isPublicHoliday = publicHolidays.includes(dateStr);
            
            if (daySchedule && daySchedule.enabled && !isPublicHoliday) {
              expectedWorkdays++;
            }
          }

          daysAbsent = Math.max(0, expectedWorkdays - daysWorked);
          const attendanceRate = expectedWorkdays > 0 ? ((daysWorked / expectedWorkdays) * 100).toFixed(1) : 0;
          const regularHours = totalHours - totalOvertime;
          const hourlyRate = employee.hourlyRate || 0;
          const regularPay = regularHours * hourlyRate;
          const overtimePay = totalOvertime * hourlyRate * 1.5; // 1.5x for overtime
          const totalPay = regularPay + overtimePay;

          employeeReports.push({
            employee,
            daysWorked,
            daysAbsent,
            daysLate,
            attendanceRate,
            totalHours,
            regularHours,
            totalOvertime,
            hourlyRate,
            regularPay,
            overtimePay,
            totalPay,
            expectedWorkdays
          });
        }

        // Calculate overall statistics
        const totalEmployees = employeeReports.length;
        const totalDaysWorked = employeeReports.reduce((sum, r) => sum + r.daysWorked, 0);
        const totalHoursWorked = employeeReports.reduce((sum, r) => sum + r.totalHours, 0);
        const totalOvertimeHours = employeeReports.reduce((sum, r) => sum + r.totalOvertime, 0);
        const totalPayroll = employeeReports.reduce((sum, r) => sum + r.totalPay, 0);
        const avgAttendanceRate = totalEmployees > 0 
          ? (employeeReports.reduce((sum, r) => sum + parseFloat(r.attendanceRate), 0) / totalEmployees).toFixed(1)
          : 0;

        // Render reports
        display.innerHTML = `
          <!-- Report Header -->
          <div class="report-header">
            <h3>üìä Monthly Report - ${monthName}</h3>
            <p>Generated on ${new Date().toLocaleString()}</p>
          </div>

          <!-- Overall Statistics -->
          <div class="report-stats">
            <div class="stat-card">
              <div class="stat-label">Total Employees</div>
              <div class="stat-value">${totalEmployees}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Total Hours Worked</div>
              <div class="stat-value">${totalHoursWorked.toFixed(1)}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Overtime Hours</div>
              <div class="stat-value">${totalOvertimeHours.toFixed(1)}</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Avg Attendance</div>
              <div class="stat-value">${avgAttendanceRate}%</div>
            </div>
            <div class="stat-card highlight">
              <div class="stat-label">Total Payroll</div>
              <div class="stat-value">R ${totalPayroll.toFixed(2)}</div>
            </div>
          </div>

          <!-- Attendance Summary Table -->
          <div class="report-section">
            <h4>Attendance Summary</h4>
            <table class="report-table">
              <thead>
                <tr>
                  <th>Employee</th>
                  <th>Slot</th>
                  <th>Days Worked</th>
                  <th>Days Absent</th>
                  <th>Times Late</th>
                  <th>Attendance %</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
                ${employeeReports.map(report => {
                  const status = parseFloat(report.attendanceRate) >= 95 ? '‚úÖ Excellent' :
                                parseFloat(report.attendanceRate) >= 85 ? 'üëç Good' :
                                parseFloat(report.attendanceRate) >= 70 ? '‚ö†Ô∏è Fair' : '‚ùå Poor';
                  return `
                    <tr>
                      <td>${report.employee.employeeName}</td>
                      <td>${report.employee.slot || report.employee.id}</td>
                      <td>${report.daysWorked}</td>
                      <td>${report.daysAbsent}</td>
                      <td>${report.daysLate}</td>
                      <td>${report.attendanceRate}%</td>
                      <td>${status}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          </div>

          <!-- Hours and Payroll Report -->
          <div class="report-section">
            <h4>Hours & Payroll Report</h4>
            <table class="report-table">
              <thead>
                <tr>
                  <th>Employee</th>
                  <th>Slot</th>
                  <th>Regular Hours</th>
                  <th>Overtime Hours</th>
                  <th>Total Hours</th>
                  <th>Hourly Rate</th>
                  <th>Regular Pay</th>
                  <th>OT Pay (1.5x)</th>
                  <th>Total Pay</th>
                </tr>
              </thead>
              <tbody>
                ${employeeReports.map(report => `
                  <tr>
                    <td>${report.employee.employeeName}</td>
                    <td>${report.employee.slot || report.employee.id}</td>
                    <td>${report.regularHours.toFixed(2)}</td>
                    <td>${report.totalOvertime.toFixed(2)}</td>
                    <td><strong>${report.totalHours.toFixed(2)}</strong></td>
                    <td>R ${report.hourlyRate.toFixed(2)}</td>
                    <td>R ${report.regularPay.toFixed(2)}</td>
                    <td>R ${report.overtimePay.toFixed(2)}</td>
                    <td><strong>R ${report.totalPay.toFixed(2)}</strong></td>
                  </tr>
                `).join('')}
                <tr class="total-row">
                  <td colspan="2"><strong>TOTALS</strong></td>
                  <td><strong>${employeeReports.reduce((sum, r) => sum + r.regularHours, 0).toFixed(2)}</strong></td>
                  <td><strong>${totalOvertimeHours.toFixed(2)}</strong></td>
                  <td><strong>${totalHoursWorked.toFixed(2)}</strong></td>
                  <td>-</td>
                  <td><strong>R ${employeeReports.reduce((sum, r) => sum + r.regularPay, 0).toFixed(2)}</strong></td>
                  <td><strong>R ${employeeReports.reduce((sum, r) => sum + r.overtimePay, 0).toFixed(2)}</strong></td>
                  <td><strong>R ${totalPayroll.toFixed(2)}</strong></td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- Payrun Summary Section -->
          <div style="margin-top: 2rem; display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
            ${(() => {
              // Calculate potential payrun first for saved revenue calculation
              let potentialHours = 0;
              let potentialPay = 0;
              let totalExpectedDays = 0;

              employeeReports.forEach(emp => {
                const expectedWorkdays = emp.expectedWorkdays || 0;
                totalExpectedDays += expectedWorkdays;
                
                let totalScheduledHours = 0;
                for (let day = 1; day <= daysInMonth; day++) {
                  const date = new Date(year, monthNum - 1, day);
                  const dateStr = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                  const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
                  const daySchedule = schedule[dayOfWeek];
                  const isPublicHoliday = publicHolidays.includes(dateStr);
                  
                  if (daySchedule && daySchedule.enabled && !isPublicHoliday) {
                    const start = daySchedule.startTime || '08:00';
                    const end = daySchedule.endTime || '17:00';
                    const [startH, startM] = start.split(':').map(Number);
                    const [endH, endM] = end.split(':').map(Number);
                    const dayHours = (endH + endM/60) - (startH + startM/60);
                    totalScheduledHours += dayHours;
                  }
                }
                
                potentialHours += totalScheduledHours;
                const hourlyRate = emp.hourlyRate || 0;
                potentialPay += totalScheduledHours * hourlyRate;
              });

              const savedRevenue = potentialPay - totalPayroll;

              return `
            <div style="background: #fff3cd; padding: 2rem; border-radius: 12px; border: 2px solid #ffc107;">
              <h3 style="margin: 0 0 1rem 0; color: #856404; font-size: 1.3rem;">üí∞ Current Payrun (Actual)</h3>
              <div style="display: grid; gap: 1rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #ffeaa7;">
                  <span style="color: #856404; font-weight: 600;">Total Employees:</span>
                  <span style="font-size: 1.2rem; font-weight: bold; color: #856404;">${employees.length}</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #ffeaa7;">
                  <span style="color: #856404; font-weight: 600;">Total Hours Worked:</span>
                  <span style="font-size: 1.2rem; font-weight: bold; color: #856404;">${totalHoursWorked.toFixed(2)} hrs</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #ffeaa7;">
                  <span style="color: #856404; font-weight: 600;">Days Worked:</span>
                  <span style="font-size: 1.2rem; font-weight: bold; color: #856404;">${employeeReports.reduce((sum, r) => sum + r.daysWorked, 0)}</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #ffeaa7;">
                  <span style="color: #856404; font-weight: 600;">Revenue Saved (Absences):</span>
                  <span style="font-size: 1.2rem; font-weight: bold; color: #28a745;">R ${savedRevenue.toFixed(2)}</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 0.5rem; margin-top: 0.5rem; border-top: 2px solid #ffc107;">
                  <span style="color: #856404; font-weight: 700; font-size: 1.1rem;">TOTAL PAYRUN:</span>
                  <span style="font-size: 1.5rem; font-weight: bold; color: #856404;">R ${totalPayroll.toFixed(2)}</span>
                </div>
              </div>
            </div>

            <div style="background: #d4edda; padding: 2rem; border-radius: 12px; border: 2px solid #28a745;">
              <h3 style="margin: 0 0 1rem 0; color: #155724; font-size: 1.3rem;">üéØ Potential Payrun (100% Attendance)</h3>
              <div style="display: grid; gap: 1rem;">
                ${(() => {
                  const missedOpportunity = potentialPay - totalPayroll;

                  return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #b7e4c7;">
                      <span style="color: #155724; font-weight: 600;">Potential Hours:</span>
                      <span style="font-size: 1.2rem; font-weight: bold; color: #155724;">${potentialHours.toFixed(2)} hrs</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #b7e4c7;">
                      <span style="color: #155724; font-weight: 600;">Expected Days:</span>
                      <span style="font-size: 1.2rem; font-weight: bold; color: #155724;">${totalExpectedDays}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.5rem; border-bottom: 1px solid #b7e4c7;">
                      <span style="color: #155724; font-weight: 600;">Hours Lost to Absence:</span>
                      <span style="font-size: 1.2rem; font-weight: bold; color: #d9534f;">${(potentialHours - totalHoursWorked).toFixed(2)} hrs</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 0.5rem; margin-top: 0.5rem; border-top: 2px solid #28a745;">
                      <span style="color: #155724; font-weight: 700; font-size: 1.1rem;">POTENTIAL PAYRUN:</span>
                      <span style="font-size: 1.5rem; font-weight: bold; color: #155724;">R ${potentialPay.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 0.5rem; background: #f8d7da; padding: 0.75rem; border-radius: 6px; margin-top: 1rem;">
                      <span style="color: #721c24; font-weight: 600;">Lost Revenue:</span>
                      <span style="font-size: 1.3rem; font-weight: bold; color: #721c24;">R ${missedOpportunity.toFixed(2)}</span>
                    </div>
                  `;
                })()}
              </div>
            </div>
            `;
            })()}
          </div>
        `;

      } catch (error) {
        console.error("Error loading reports:", error);
        display.innerHTML = '<div style="text-align: center; padding: 3rem; color: #e53e3e;">Error loading reports: ' + error.message + '</div>';
      }
    }

    function printReports() {
      window.print();
    }

    // Make reports functions globally available
    window.loadReports = loadReports;
    window.printReports = printReports;
    window.initReports = initReports;

    // ============================================
    // DOWNLOADS MODULE FUNCTIONS
    // ============================================
    
    async function loadDownloads() {
      const monitorUrl = `${window.location.origin}/pages/monitor-app.html?businessId=${businessId}`;
      
      const downloadsHTML = `
        <div style="max-width: 900px; margin: 0 auto; padding: 2rem;">
          <h2 style="margin-bottom: 2rem; font-size: 1.8rem; color: #333;">üì• Downloads & Apps</h2>
          
          <!-- Monitor App Card -->
          <div style="background: white; border-radius: 12px; padding: 2rem; margin-bottom: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: start; gap: 1.5rem;">
              <div style="font-size: 4rem;">üì±</div>
              <div style="flex: 1;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.5rem; color: #667eea;">Monitor Mode App</h3>
                <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                  Dedicated app for Android tablets/phones that displays live employee attendance status. 
                  Perfect for mounting on office walls or reception desks.
                </p>
                
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                  <h4 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Features:</h4>
                  <ul style="margin: 0.5rem 0 0 1.5rem; color: #666;">
                    <li>Real-time attendance updates</li>
                    <li>Large, easy-to-read employee cards</li>
                    <li>Shows IN/OUT status with timestamps</li>
                    <li>Auto-refresh every 30 seconds</li>
                    <li>Works offline (cached data)</li>
                    <li>Full-screen mode support</li>
                  </ul>
                </div>

                <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                  <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: #92400e;">üì± Installation Instructions for Android:</h4>
                  <ol style="margin: 0.5rem 0 0 1.2rem; font-size: 0.9rem; line-height: 1.8; color: #78350f;">
                    <li><strong>Scan QR Code below</strong> or click "Open Monitor App" button</li>
                    <li>On your Android device, tap the <strong>menu (‚ãÆ)</strong> in browser</li>
                    <li>Select <strong>"Add to Home screen"</strong> or <strong>"Install app"</strong></li>
                    <li>Name it "Attendance Monitor" and tap Add</li>
                    <li>App icon will appear on your home screen - tap to open</li>
                    <li>Enable full-screen mode from app settings</li>
                  </ol>
                </div>

                <div style="display: flex; gap: 1rem; align-items: center; margin-top: 1.5rem;">
                  <button onclick="window.open('${monitorUrl}', '_blank')" 
                          style="padding: 0.75rem 1.5rem; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1rem;">
                    üöÄ Open Monitor App
                  </button>
                  
                  <button onclick="copyMonitorUrl()" 
                          style="padding: 0.75rem 1.5rem; background: white; color: #667eea; border: 2px solid #667eea; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1rem;">
                    üìã Copy Link
                  </button>
                </div>

                <!-- QR Code -->
                <div style="margin-top: 1.5rem;">
                  <p style="font-weight: 600; margin-bottom: 0.5rem;">üì∏ Scan with phone camera:</p>
                  <div id="qrcode" style="background: white; padding: 1rem; display: inline-block; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
                </div>

                <!-- Share Link -->
                <div style="margin-top: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                  <p style="font-weight: 600; margin: 0 0 0.5rem 0; font-size: 0.9rem;">Monitor App Link:</p>
                  <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <input type="text" id="monitorUrlInput" value="${monitorUrl}" readonly
                           style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85rem;">
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Coming Soon Card -->
          <div style="background: white; border-radius: 12px; padding: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); opacity: 0.7;">
            <div style="display: flex; align-items: start; gap: 1.5rem;">
              <div style="font-size: 4rem;">üöß</div>
              <div style="flex: 1;">
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.5rem; color: #666;">More Apps Coming Soon</h3>
                <p style="margin: 0; color: #666; line-height: 1.6;">
                  We're working on additional apps including:
                </p>
                <ul style="margin: 0.5rem 0 0 1.5rem; color: #666;">
                  <li>Employee Self-Service Mobile App</li>
                  <li>Manager Dashboard App</li>
                  <li>Desktop Time Clock App</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      `;

      // Insert HTML into dashboard view (replace the modules grid)
      const dashboardView = document.getElementById('dashboardView');
      if (dashboardView) {
        dashboardView.innerHTML = downloadsHTML;

        // Generate QR Code
        loadQRCodeLibrary().then(() => {
          new QRCode(document.getElementById('qrcode'), {
            text: monitorUrl,
            width: 200,
            height: 200,
            colorDark: '#000000',
            colorLight: '#ffffff',
          });
        });
      }
    }

    function loadQRCodeLibrary() {
      return new Promise((resolve) => {
        if (window.QRCode) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js';
        script.onload = resolve;
        document.head.appendChild(script);
      });
    }

    window.copyMonitorUrl = function() {
      const input = document.getElementById('monitorUrlInput');
      input.select();
      document.execCommand('copy');
      alert('‚úÖ Monitor app link copied to clipboard!');
    };

    window.loadDownloads = loadDownloads;

    // ============================================
    // SETTINGS MODULE FUNCTIONS
    // ============================================
    
    async function loadSettings() {
      try {
        // Load business data
        const businessRef = doc(db, "businesses", businessId);
        const businessDoc = await getDoc(businessRef);
        
        if (businessDoc.exists()) {
          const data = businessDoc.data();
          
          // Business Info
          document.getElementById('businessName').value = data.businessName || '';
          document.getElementById('businessPhone').value = data.phone || data.phoneNumber || '';
          document.getElementById('businessEmail').value = data.adminEmail || '';
          document.getElementById('businessCurrency').value = data.currency || 'R';
          
          // Working Days with Schedule
          const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
          days.forEach(day => {
            const dayData = data.schedule?.[day] || {};
            document.getElementById(day).checked = dayData.enabled || data[day] || false;
            document.getElementById(day + 'Start').value = dayData.startTime || '08:00';
            document.getElementById(day + 'End').value = dayData.endTime || (day === 'saturday' ? '14:30' : '17:00');
            document.getElementById(day + 'Rate').value = dayData.payRate || '';
          });
          
          // Public Holidays
          document.getElementById('publicHolidays').value = (data.publicHolidays || []).join('\n');
          
          // Working Hours
          document.getElementById('breakDuration').value = data.breakDuration || 60;
          document.getElementById('overtimeRule').value = data.overtimeRule || 'none';
          document.getElementById('overtimeMultiplier').value = data.overtimeMultiplier || 1.5;
        }
        
        // Setup form handlers
        document.getElementById('businessInfoForm').addEventListener('submit', saveBusinessInfo);
        document.getElementById('workingDaysForm').addEventListener('submit', saveWorkingDays);
        document.getElementById('publicHolidaysForm').addEventListener('submit', savePublicHolidays);
        document.getElementById('workingHoursForm').addEventListener('submit', saveWorkingHours);
        
      } catch (error) {
        console.error("Error loading settings:", error);
        alert('Error loading settings: ' + error.message);
      }
    }
    
    async function saveBusinessInfo(e) {
      e.preventDefault();
      try {
        const businessRef = doc(db, "businesses", businessId);
        await setDoc(businessRef, {
          businessName: document.getElementById('businessName').value,
          phone: document.getElementById('businessPhone').value,
          adminEmail: document.getElementById('businessEmail').value,
          currency: document.getElementById('businessCurrency').value,
          updatedAt: new Date().toISOString()
        }, { merge: true });
        
        alert('‚úÖ Business information saved successfully!');
      } catch (error) {
        console.error("Error saving business info:", error);
        alert('Error saving: ' + error.message);
      }
    }
    
    async function saveWorkingDays(e) {
      e.preventDefault();
      try {
        const businessRef = doc(db, "businesses", businessId);
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
        const schedule = {};
        
        days.forEach(day => {
          schedule[day] = {
            enabled: document.getElementById(day).checked,
            startTime: document.getElementById(day + 'Start').value,
            endTime: document.getElementById(day + 'End').value,
            payRate: parseFloat(document.getElementById(day + 'Rate').value) || 0
          };
        });
        
        await setDoc(businessRef, {
          schedule: schedule,
          updatedAt: new Date().toISOString()
        }, { merge: true });
        
        alert('‚úÖ Working schedule saved successfully!');
      } catch (error) {
        console.error("Error saving working days:", error);
        alert('Error saving: ' + error.message);
      }
    }
    
    async function savePublicHolidays(e) {
      e.preventDefault();
      try {
        const businessRef = doc(db, "businesses", businessId);
        const holidaysText = document.getElementById('publicHolidays').value;
        const holidays = holidaysText.split('\n').map(h => h.trim()).filter(h => h.length > 0);
        
        await setDoc(businessRef, {
          publicHolidays: holidays,
          updatedAt: new Date().toISOString()
        }, { merge: true });
        
        alert('‚úÖ Public holidays saved successfully!');
      } catch (error) {
        console.error("Error saving holidays:", error);
        alert('Error saving: ' + error.message);
      }
    }
    
    async function saveWorkingHours(e) {
      e.preventDefault();
      try {
        const businessRef = doc(db, "businesses", businessId);
        await setDoc(businessRef, {
          breakDuration: parseInt(document.getElementById('breakDuration').value),
          overtimeRule: document.getElementById('overtimeRule').value,
          overtimeMultiplier: parseFloat(document.getElementById('overtimeMultiplier').value),
          updatedAt: new Date().toISOString()
        }, { merge: true });
        
        alert('‚úÖ Working hours rules saved successfully!');
      } catch (error) {
        console.error("Error saving working hours:", error);
        alert('Error saving: ' + error.message);
      }
    }

    // Debug functions for testing
    async function addTestEmployee() {
      try {
        const staffRef = collection(db, "businesses", businessId, "staff");
        const slotRef = doc(staffRef, "1");
        await setDoc(slotRef, {
          employeeId: "1",
          employeeName: "John Smith",
          badgeNumber: "1001",
          deviceId: "device_1",
          slot: 1,
          active: true,
          assignedAt: new Date().toISOString(),
          createdAt: new Date().toISOString()
        });
        console.log("Test employee added (IN)");
        loadMonitorData();
      } catch (error) {
        console.error("Error adding test employee:", error);
        alert("Error: " + error.message);
      }
    }

    async function addTestEmployeeOut() {
      try {
        const staffRef = collection(db, "businesses", businessId, "staff");
        const slotRef = doc(staffRef, "2");
        await setDoc(slotRef, {
          employeeId: "2",
          employeeName: "Jane Doe",
          badgeNumber: "1002",
          deviceId: "device_2",
          slot: 2,
          active: false,
          assignedAt: new Date().toISOString(),
          createdAt: new Date().toISOString(),
          outTime: new Date().getTime()
        });
        console.log("Test employee added (OUT)");
        loadMonitorData();
      } catch (error) {
        console.error("Error adding test employee:", error);
        alert("Error: " + error.message);
      }
    }

    async function clearAllStaff() {
      try {
        if (!confirm("Are you sure? This will clear all staff data.")) return;
        
        const staffRef = collection(db, "businesses", businessId, "staff");
        const staffSnap = await getDocs(staffRef);
        
        for (let doc of staffSnap.docs) {
          await deleteDoc(doc.ref);
        }
        console.log("All staff cleared");
        loadMonitorData();
      } catch (error) {
        console.error("Error clearing staff:", error);
        alert("Error: " + error.message);
      }
    }

    // Failsafe: Set up basic event listeners if main initialization fails
    setTimeout(() => {
      try {
        if (!window.listenersSetup) {
          console.log('Failsafe: Setting up event listeners...');
          
          document.querySelectorAll('.menu-btn[data-module]').forEach(btn => {
            const module = btn.dataset.module;
            btn.onclick = function(e) {
              e.preventDefault();
              console.log('Failsafe click:', module);
              switchModule(module);
            };
          });
          
          window.listenersSetup = true;
          console.log('Failsafe event listeners set up');
        }
      } catch (error) {
        console.error('Failsafe setup error:', error);
      }
    }, 2000);
  </script>

  <!-- Optional SQL Device Integration Module -->
  <script src="../modules/sql-device-integration.js"></script>
  
  <!-- Firebase Data Connect Integration Module -->
  <script type="module" src="../modules/firebase-dataconnect-integration.js"></script>
  
  <script>
    // Optional SQL Integration Setup (non-breaking)
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // Initialize SQL integration if available
        if (window.sqlDeviceIntegration) {
          console.log('üîå SQL Device Integration available');
          
          // Try to initialize (will fallback gracefully if SQL service isn't running)
          const result = await window.sqlDeviceIntegration.initialize({
            sqlEndpoint: 'http://localhost:3001',
            syncInterval: 30000
          });
          
          if (result.success) {
            console.log('‚úÖ SQL integration enabled - dual storage active');
            
            // Add SQL status indicator to dashboard
            if (document.getElementById('dashboard')) {
              const statusDiv = document.createElement('div');
              statusDiv.id = 'sql-status';
              statusDiv.innerHTML = `
                <div style="position: fixed; top: 10px; right: 10px; background: #4CAF50; color: white; padding: 8px 12px; border-radius: 5px; font-size: 12px; z-index: 1000;">
                  üìä SQL Integration: Active
                </div>
              `;
              document.body.appendChild(statusDiv);
            }
          } else {
            console.log('‚ÑπÔ∏è SQL integration unavailable - using Firestore only');
          }
        }
      } catch (error) {
        console.log('‚ÑπÔ∏è SQL integration not loaded - continuing with standard functionality');
      }

      // Setup SQL Integration Tab functionality
      setupSQLIntegrationTab();
      
      // Setup Firebase Data Connect functionality
      setupDataConnectTab();
    });

    // SQL Integration Tab Functions
    function setupSQLIntegrationTab() {
      const testConnectionBtn = document.getElementById('sqlTestConnectionBtn');
      const startServiceBtn = document.getElementById('sqlStartServiceBtn');
      
      if (testConnectionBtn) {
        testConnectionBtn.addEventListener('click', testSQLConnection);
      }
      
      if (startServiceBtn) {
        startServiceBtn.addEventListener('click', showStartInstructions);
      }
      
      // Update status when tab is opened
      const sqlTab = document.querySelector('[data-module="sql-integration"]');
      if (sqlTab) {
        sqlTab.addEventListener('click', updateSQLStatus);
      }
    }

    // Firebase Data Connect Tab Functions
    function setupDataConnectTab() {
      const initBtn = document.getElementById('dataConnectInitBtn');
      const testBtn = document.getElementById('dataConnectTestBtn');
      const addDeviceBtn = document.getElementById('addHikvisionDeviceBtn');
      
      if (initBtn) {
        initBtn.addEventListener('click', initializeDataConnect);
      }
      
      if (testBtn) {
        testBtn.addEventListener('click', testDataConnect);
      }
      
      if (addDeviceBtn) {
        addDeviceBtn.addEventListener('click', showAddDeviceModal);
      }
    }

    // Firebase Data Connect Functions
    async function initializeDataConnect() {
      const statusText = document.getElementById('dataConnectStatusText');
      const connectionStatus = document.getElementById('dataConnectConnectionStatus');
      const initBtn = document.getElementById('dataConnectInitBtn');
      
      statusText.textContent = 'Connecting to device sync service...';
      connectionStatus.textContent = 'Connecting...';
      initBtn.disabled = true;
      
      try {
        // Test connection to Hikvision sync service
        const response = await fetch('http://localhost:3002/health');
        
        if (response.ok) {
          const data = await response.json();
          statusText.textContent = 'Connected to device sync service!';
          connectionStatus.textContent = 'Connected';
          
          // Show additional buttons
          document.getElementById('dataConnectTestBtn').style.display = 'inline-block';
          document.getElementById('addHikvisionDeviceBtn').style.display = 'inline-block';
          
          initBtn.textContent = '‚úÖ Device Sync Active';
          initBtn.style.background = '#4CAF50';
          
          console.log('‚úÖ Hikvision sync service connected:', data);
        } else {
          throw new Error('Service not available');
        }
      } catch (error) {
        statusText.textContent = 'Device sync service not running';
        connectionStatus.textContent = 'Error';
        initBtn.disabled = false;
        alert(`Device sync service not running. Please start the service first.`);
      }
    }

    async function testDataConnect() {
      try {
        const response = await fetch('http://localhost:3002/devices');
        const data = await response.json();
        alert(`Device sync test successful! Found ${data.count} devices.`);
      } catch (error) {
        alert(`Device sync test failed: ${error.message}`);
      }
    }

    function showAddDeviceModal() {
      const deviceIP = prompt('Enter Hikvision device IP address:', '192.168.0.114');
      if (!deviceIP) return;
      
      const deviceName = prompt('Enter device name (optional):', 'Main Entrance Camera');
      const username = prompt('Enter device username:', 'admin');
      const password = prompt('Enter device password:');
      
      if (password) {
        addHikvisionDevice(deviceIP, deviceName, username, password);
      }
    }

    async function addHikvisionDevice(ip, name, username, password) {
      try {
        // Test device connection first
        const testResponse = await fetch('http://localhost:3002/device/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ip, username, password })
        });
        
        const testResult = await testResponse.json();
        
        if (!testResult.connected) {
          alert(`‚ùå Failed to connect to device at ${ip}:
          
Error: ${testResult.error}
Suggestion: ${testResult.suggestion}

Please check:
‚Ä¢ Device IP address: ${ip}
‚Ä¢ Username: ${username}
‚Ä¢ Password: [verify password]
‚Ä¢ Network connectivity`);
          return;
        }
        
        // Add device to sync service
        const addResponse = await fetch('http://localhost:3002/device/add', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, ip, username, password })
        });
        
        const addResult = await addResponse.json();
        
        if (addResult.success) {
          // Start device sync
          const startResponse = await fetch(`http://localhost:3002/device/${addResult.device.id}/start`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ interval: 30000 })
          });
          
          const startResult = await startResponse.json();
          
          if (startResult.success) {
            // Update UI
            updateDataConnectStatus();
            
            alert(`‚úÖ Success!

Device: ${addResult.device.name}
Model: ${testResult.model}
Serial: ${testResult.serialNumber}
Firmware: ${testResult.firmwareVersion}

‚úÖ Device connected and sync started!
üîÑ Syncing every 30 seconds
üìä Real events will be captured from your Hikvision device

Check browser console for real-time sync logs.`);
          } else {
            throw new Error('Failed to start sync');
          }
        } else {
          throw new Error('Failed to add device');
        }
        
      } catch (error) {
        alert(`Failed to add device: ${error.message}`);
      }
    }

    async function updateDataConnectStatus() {
      try {
        const response = await fetch('http://localhost:3002/devices');
        const data = await response.json();
        
        let totalEvents = 0;
        data.devices.forEach(device => {
          totalEvents += device.eventCount || 0;
        });
        
        document.getElementById('dataConnectEventCount').textContent = totalEvents;
        document.getElementById('dataConnectDatabaseStatus').textContent = 
          `${data.count} device(s) connected`;
      } catch (error) {
        console.error('Failed to update status:', error);
      }
    }

    async function testSQLConnection() {
      const statusText = document.getElementById('sqlStatusText');
      const connectionStatus = document.getElementById('sqlConnectionStatus');
      const devicesContent = document.getElementById('sqlDevicesContent');
      
      statusText.textContent = 'Testing connection...';
      connectionStatus.textContent = 'Testing...';
      
      try {
        const response = await fetch('http://localhost:3001/health', { 
          method: 'GET',
          timeout: 3000 
        });
        
        if (response.ok) {
          const data = await response.json();
          statusText.textContent = 'Connected to SQL service!';
          connectionStatus.textContent = 'Connected';
          document.getElementById('sqlDatabaseStatus').textContent = data.database || 'Connected';
          
          if (devicesContent) {
            devicesContent.innerHTML = `
              <div style="text-align: center; color: #4CAF50; padding: 2rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">‚úÖ</div>
                <p><strong>SQL Service Connected!</strong></p>
                <p>Ready for enhanced device integration</p>
              </div>
            `;
          }
        } else {
          throw new Error('Service unavailable');
        }
      } catch (error) {
        if (statusText) statusText.textContent = 'SQL service not running';
        if (connectionStatus) connectionStatus.textContent = 'Disconnected';
        const dbStatus = document.getElementById('sqlDatabaseStatus');
        if (dbStatus) dbStatus.textContent = 'Not connected';
        
        if (devicesContent) {
          devicesContent.innerHTML = `
            <div style="text-align: center; color: #f44336; padding: 2rem;">
              <div style="font-size: 3rem; margin-bottom: 1rem;">‚ùå</div>
              <p><strong>SQL Service Offline</strong></p>
              <p>Please start the SQL service first</p>
            </div>
          `;
        }
      }
    }

    function showStartInstructions() {
      alert(`To start the SQL service:

1. Open Terminal
2. Navigate to your project: cd "path/to/aiclock"
3. Go to SQL service: cd sql-service
4. Install dependencies: npm install (if not already done)
5. Start service: npm start

The service will run on http://localhost:3001

Click "Test Connection" after starting the service.`);
    }

    async function updateSQLStatus() {
      // Auto-update status when SQL tab is opened
      setTimeout(testSQLConnection, 500);
    }

    // REAL DEVICE SYNC FUNCTIONS
    let deviceSyncInterval = null;

    document.getElementById('deviceConnectForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      await connectToDevice();
    });

    document.getElementById('startSyncBtn').addEventListener('click', startLiveSync);
    document.getElementById('stopSyncBtn').addEventListener('click', stopLiveSync);
    document.getElementById('credentialHelperBtn').addEventListener('click', toggleCredentialHelper);

    function toggleCredentialHelper() {
      const helper = document.getElementById('credentialHelper');
      if (helper.style.display === 'none' || !helper.style.display) {
        helper.style.display = 'block';
      } else {
        helper.style.display = 'none';
      }
    }

    function useCredentials(username, password) {
      document.getElementById('deviceUsername').value = username;
      document.getElementById('devicePassword').value = password;
      document.getElementById('credentialHelper').style.display = 'none';
      
      // Automatically test connection
      setTimeout(() => {
        document.getElementById('deviceConnectForm').dispatchEvent(new Event('submit'));
      }, 500);
    }

    // Make functions globally available
    window.useCredentials = useCredentials;

    async function connectToDevice() {
      const ip = document.getElementById('deviceIp').value;
      const username = document.getElementById('deviceUsername').value;
      const password = document.getElementById('devicePassword').value;
      const deviceStatus = document.getElementById('deviceStatus');
      const deviceResults = document.getElementById('deviceResults');

      deviceStatus.textContent = 'Connecting...';
      deviceStatus.style.background = '#ffc107';

      try {
        const response = await fetch('http://localhost:3002/device/test', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ip, username, password })
        });

        const result = await response.json();

        if (result.connected) {
          deviceStatus.textContent = 'Device Online';
          deviceStatus.style.background = '#28a745';
          
          document.getElementById('startSyncBtn').disabled = false;
          document.getElementById('startSyncBtn').style.opacity = '1';
          
          deviceResults.innerHTML = `
            <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
              <h4 style="margin: 0 0 0.5rem 0; color: #155724;">‚úÖ Device Connected Successfully!</h4>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem; font-size: 14px;">
                <div><strong>Device Model:</strong> ${result.model || 'N/A'}</div>
                <div><strong>Firmware:</strong> ${result.firmwareVersion || 'N/A'}</div>
                <div><strong>Serial Number:</strong> ${result.serialNumber || 'N/A'}</div>
                <div><strong>Connection Status:</strong> <span style="color: #28a745; font-weight: bold;">Online</span></div>
              </div>
            </div>
          `;
        } else {
          throw new Error(result.error || 'Failed to connect to device');
        }
      } catch (error) {
        deviceStatus.textContent = 'Connection Failed';
        deviceStatus.style.background = '#dc3545';
        
        // Enhanced error display with suggestions
        let errorMessage = error.message;
        let suggestions = '';
        
        // If it's from our sync service, it might have detailed suggestions
        if (error.message.includes('Authentication failed') || error.message.includes('401')) {
          errorMessage = 'Authentication Failed (401)';
          suggestions = `
            <div style="margin-top: 1rem;">
              <strong>üîë Try these common Hikvision credentials:</strong>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.5rem; margin: 0.5rem 0; font-family: monospace; background: #f8f9fa; padding: 1rem; border-radius: 4px;">
                <div>admin / password</div>
                <div>admin / 12345</div>
                <div>admin / admin</div>
                <div>admin / 123456</div>
                <div>admin / [blank]</div>
                <div>root / password</div>
              </div>
              <p style="font-size: 14px; color: #666; margin: 0.5rem 0;">
                <strong>Tip:</strong> Check your camera's label or manual for default credentials.
                Some cameras require you to set a password on first use.
              </p>
            </div>
          `;
        }
        
        deviceResults.innerHTML = `
          <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="margin: 0 0 0.5rem 0; color: #721c24;">‚ùå ${errorMessage}</h4>
            <div style="margin-top: 1rem; font-size: 14px;">
              <strong>Device Details:</strong>
              <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                <li>IP Address: ${ip}</li>
                <li>Username: ${username}</li>
                <li>Password: ${'*'.repeat(password.length)} (${password.length} characters)</li>
              </ul>
            </div>
            ${suggestions}
            <div style="margin-top: 1rem; font-size: 14px;">
              <strong>Troubleshooting Steps:</strong>
              <ol style="margin: 0.5rem 0; padding-left: 1.5rem;">
                <li>Verify device IP: ${ip} (device is reachable ‚úÖ)</li>
                <li>Check username and password above</li>
                <li>Access camera web interface at <a href="http://${ip}" target="_blank">http://${ip}</a></li>
                <li>Ensure ISAPI is enabled in camera settings</li>
              </ol>
            </div>
          </div>
        `;
      }
    }

    async function loadHistoricalEvents(ip) {
      const eventsList = document.getElementById('eventsList');
      
      try {
        console.log('Loading historical events for:', ip);
        const response = await fetch(`http://localhost:3002/device/events?ip=${ip}&limit=20`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const events = await response.json();
        console.log('Loaded events:', events.length);
        
        if (events && events.length > 0) {
          // Clear placeholder
          eventsList.innerHTML = '';
          
          // Display events
          events.forEach(event => {
            displayEvent(event);
          });
          
          // Add status header
          const headerDiv = document.createElement('div');
          headerDiv.style.cssText = `
            text-align: center; 
            color: #28a745; 
            padding: 1rem; 
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            font-weight: bold;
          `;
          headerDiv.innerHTML = `üì° Showing ${events.length} recent events - Live sync active`;
          eventsList.prepend(headerDiv);
        } else {
          eventsList.innerHTML = `
            <div style="text-align: center; color: #ffc107; padding: 2rem;">
              <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚ö†Ô∏è</div>
              No events found for device ${ip}
              <div style="font-size: 12px; margin-top: 10px;">Import events first or wait for new events</div>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error loading historical events:', error);
        eventsList.innerHTML = `
          <div style="text-align: center; color: #dc3545; padding: 2rem;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚ùå</div>
            Failed to load events: ${error.message}
            <div style="font-size: 12px; margin-top: 10px;">Check if sync service is running</div>
          </div>
        `;
      }
    }

    function displayEvent(event) {
      const eventsList = document.getElementById('eventsList');
      const eventDiv = document.createElement('div');
      
      // Determine event source and styling
      let isDemo = false;
      let isHistorical = false;
      let borderColor = '#28a745';
      let bgColor = '#d4edda';
      let icon = 'üìπ';
      let badge = '';
      
      if (event.source === 'DEMO' || event.source === 'SIMULATED_DEMO') {
        isDemo = true;
        borderColor = '#ffc107';
        bgColor = '#fff3cd';
        icon = 'üé≠';
        badge = '<span style="background: #ffc107; color: #856404; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;">DEMO</span>';
      } else if (event.source === 'HISTORICAL_SAMPLE') {
        isHistorical = true;
        borderColor = '#6c757d';
        bgColor = '#f8f9fa';
        icon = 'üìÇ';
        badge = '<span style="background: #6c757d; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;">HISTORICAL</span>';
      }
      
      eventDiv.style.cssText = `
        padding: 0.75rem; 
        margin: 0.5rem 0; 
        border-left: 4px solid ${borderColor}; 
        background: ${bgColor}; 
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      `;
      
      const timeFormatted = new Date(event.timestamp).toLocaleString();
      const eventType = event.type || event.eventType || 'Unknown Event';
      const personName = event.data?.personName || event.personName || 'Unknown Person';
      const result = event.data?.result || event.result || '';
      
      eventDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start;">
          <div style="flex: 1;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
              <strong style="color: ${isDemo ? '#856404' : isHistorical ? '#6c757d' : '#155724'};">
                ${icon} ${eventType}
              </strong>
              ${badge}
            </div>
            <div style="font-size: 12px; color: #666; margin-bottom: 2px;">${timeFormatted}</div>
            <div style="font-size: 11px; color: #666;">
              üë§ ${personName} ${result ? `‚Ä¢ ${result}` : ''}
            </div>
          </div>
        </div>
      `;
      
      eventsList.appendChild(eventDiv);
    }

    async function startLiveSync() {
      const ip = document.getElementById('deviceIp').value;
      const startBtn = document.getElementById('startSyncBtn');
      const stopBtn = document.getElementById('stopSyncBtn');
      const eventsList = document.getElementById('eventsList');

      startBtn.disabled = true;
      stopBtn.disabled = false;
      stopBtn.style.opacity = '1';

      // Load initial historical events
      await loadHistoricalEvents(ip);

      // Start periodic event fetching
      deviceSyncInterval = setInterval(async () => {
        try {
          const response = await fetch(`http://localhost:3002/device/events?ip=${ip}&limit=10`);
          const events = await response.json();

          if (events.length > 0) {
            // Add new events to the list
            events.forEach(event => {
              displayEvent(event);
            });
            
            // Keep only last 20 events (plus header)
            while (eventsList.children.length > 21) {
              eventsList.removeChild(eventsList.lastChild);
            }
          }
        } catch (error) {
          console.error('Error fetching events:', error);
        }
      }, 5000); // Check every 5 seconds
    }

    function stopLiveSync() {
      if (deviceSyncInterval) {
        clearInterval(deviceSyncInterval);
        deviceSyncInterval = null;
      }

      document.getElementById('startSyncBtn').disabled = false;
      document.getElementById('stopSyncBtn').disabled = true;
      document.getElementById('stopSyncBtn').style.opacity = '0.5';

      const eventsList = document.getElementById('eventsList');
      eventsList.innerHTML = `
        <div style="text-align: center; color: #888; padding: 2rem;">
          <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚è∏Ô∏è</div>
          Sync stopped - Click "Start Live Sync" to resume
        </div>
      `;
    }
  </script>
</body>
</html>
